\paragraph{Small Sub-Blocks for Write-Through Caches}\label{paragraph: Small Sub-Blocks for Write-Through Caches}

In a \textbf{write-through cache} (page \hqpageref{Cache Write Policies: Write-Through}):
\begin{itemize}
    \item Every store operation updates \textbf{both the cache and main memory}.
    \item This can generate a \textbf{lot of traffic} to memory (or to the write buffer if one is present).
    \item If the cache block size is large (e.g., 64B), updating the entire block for a single small write is \textbf{wasteful} and increases \textbf{hit time}.
\end{itemize}
\textbf{Idea:} Divide each cache block into \textbf{smaller sub-blocks}, each with its own \textbf{valid/dirty bit}, so that \textbf{only the sub-block being written} needs to be updated.

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{tools} \textbf{How it works}}
\end{flushleft}
A cache block (say 64B) is divided into multiple \textbf{sub-blocks} (e.g., 4 sub-blocks of 16B). Each sub-block has:
\begin{itemize}
    \item Its own \important{Valid Bit} (to track if it contains valid data).
    \item Its own \important{Dirty/Modified Indicator} (\hl{if using write-back}).
\end{itemize}
On a write:
\begin{itemize}
    \item Only the affected sub-block is updated in cache.
    \item Only that sub-block's portion is sent to memory (write-through).
\end{itemize}

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{check-circle} \textbf{Benefits}}
\end{flushleft}
\begin{itemize}
    \item[\textcolor{Green3}{\faIcon{check}}] \textbf{Reduces memory traffic} for small writes.
    \item[\textcolor{Green3}{\faIcon{check}}] \textbf{Improves hit time} in write-through caches since less data moves.
    \item[\textcolor{Green3}{\faIcon{check}}] Works well with workloads that update small pieces of data frequently.
\end{itemize}
It is particularly useful in \textbf{write-through caches} because every write goes to memory, and smaller granularity avoids wasting bandwidth. Less common in \textbf{write-back caches} since writes accumulate in cache and only dirty blocks are written back, so the benefit is smaller.

\highspace
\begin{flushleft}
    \textcolor{Red2}{\faIcon{exclamation-triangle} \textbf{Trade-offs}}
\end{flushleft}
\begin{itemize}
    \item[\textcolor{Red2}{\faIcon{times}}] \textbf{Extra control logic}: Need valid/dirty bits for each sub-block.
    \item[\textcolor{Red2}{\faIcon{times}}] \textbf{More tag complexity}: Cache must track multiple sub-block states.
    \item[\textcolor{Red2}{\faIcon{times}}] \textbf{Spatial locality underused}: If later sub-blocks are needed, multiple transfers occur.
\end{itemize}
However, using \textbf{small sub-blocks} in write-through caches \textbf{reduces write bandwidth} and improves \textbf{hit time}, at the cost of slightly more control logic and reduced spatial locality exploitation.