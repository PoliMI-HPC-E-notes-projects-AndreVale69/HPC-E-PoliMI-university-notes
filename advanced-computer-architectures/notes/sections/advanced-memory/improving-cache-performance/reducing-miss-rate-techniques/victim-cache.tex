\paragraph{Victim Cache}

Even with set-associative caches, \textbf{conflict misses}\footnote{Conflict Miss happens when two or more blocks map to the same cache set, and they overwrite each other, even if the cache is not full.} can still occur when frequently accessed blocks map to the same set and keep evicting each other.

\highspace
Instead of increasing associativity (which\textbf{slows down hit time} and \textbf{increases complexity}), we can \textbf{add a small buffer} to catch those recently evicted blocks.

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{lightbulb} \textbf{Basic Idea}}
\end{flushleft}
A \definition{Victim Cache} is:
\begin{itemize}
    \item \textbf{Small} (e.g., 4-16 entries).
    \item \textbf{Fully Associative} cache.
    \item Placed \textbf{between the main cache and the next lower level} in the hierarchy.
\end{itemize}
\textbf{Process:}
\begin{enumerate}
    \item If a block is evicted from the main cache, it is moved into the Victim Cache.
    \item On a cache miss in the main cache, \textbf{check the victim cache}:
    \begin{itemize}
        \item If found there $\rightarrow$ \textbf{swap} it with the block in the main cache (\definition{Victim Block Swap}).
        \item If not found $\rightarrow$ fetch from lower memory level.
    \end{itemize}
\end{enumerate}

\begin{flushleft}
    \textcolor{Green3}{\faIcon{\speedIcon} \textbf{Effect on Miss Rate}}    
\end{flushleft}
Victim caches \textbf{reduce conflict misses} significantly, especially for \textbf{direct-mapped caches}. For example, if two memory blocks keep evicting each other from the same line in a direct-mapped cache, the victim cache allows them to \textbf{coexist} without forcing an immediate main-memory access.

\highspace
\begin{flushleft}
    \textcolor{Red2}{\faIcon{exclamation-triangle} \textbf{Trade-offs and Costs}}
\end{flushleft}
\begin{table}[!htp]
    \centering
    \begin{tabular}{@{} p{12em} l @{}}
        \toprule
        Factor & Impact \\
        \midrule
        \textcolor{Green3}{\faIcon{check} \textbf{Miss Rate Reduction}}                 & Very effective for small conflict sets.           \\ [.3em]
        \textcolor{Green3}{\faIcon{check} \textbf{No Change to Main Cache Hit Time}}    & The main cache remains fast.                      \\ [1.3em]
        \textcolor{Red2}{\faIcon{times} \textbf{Extra Hardware}}                        & Additional storage, tag comparators, swap logic.  \\ [.3em]
        \textcolor{Red2}{\faIcon{times} \textbf{Area and Power}}                        & Still small, but non-zero overhead.               \\
        \bottomrule
    \end{tabular}
\end{table}

\newpage

\begin{flushleft}
    \textcolor{Green3}{\faIcon{tools} \textbf{Simplified Flow}}
\end{flushleft}
\begin{enumerate}
    \item CPU Request.
    \item Main Cache Hit?
    \item Yes $\rightarrow$ Done.
    \item No, check Victim Cache.
    \item Found?
    \item Yes $\rightarrow$ Swap into Main Cache (Fast Recovery).
    \item No $\rightarrow$ Fetch from Lower Level.
\end{enumerate}
A \textbf{victim cache} is a low-cost, high-impact technique for \textbf{reducing conflict misses} without hurting hit time. It acts as a \textbf{safety net} for blocks that would otherwise be lost to the next memory level.
