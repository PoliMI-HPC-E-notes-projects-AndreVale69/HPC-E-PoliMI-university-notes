\subsection{Principle of Locality}

\hl{Cache memories are effective because programs tend to access data and instructions in} \textbf{predictable patterns}. These patterns are captured by the \definition{Principle of Locality}:
\begin{itemize}
    \item \definition{Temporal Locality} (``\emph{Time-based reuse}''). \textbf{If a memory location is accessed, it's likely to be accessed again \emph{soon}}. So recently accessed data stays in cache, because it's likely to be accessed again.
    
    For example, repeated access to loop variables:
    \begin{lstlisting}[language=c]
for (int i = 0; i < n; ++i) {
    sum += a[i];
}\end{lstlisting}
    Or reuse of stack frames in recursive functions or instruction fetches inside tight loops.
    \begin{itemize}
        \item[\textcolor{Green3}{\faIcon{tools}}] \textcolor{Green3}{\textbf{Cache strategy.}} Keep recently accessed \textbf{blocks} in cache. Don't replace them unless absolutely necessary (see LRU in later sections).
    \end{itemize}


    \item \definition{Spatial Locality} (``\emph{Nearby reuse}''). \textbf{If a memory location is accessed, it's likely that \emph{nearby locations} will be accessed soon}. In other words, if we need \texttt{a[i]}, we'll probably also need \texttt{a[i+1]}, \texttt{a[i+2]}, etc.

    For example, sequential instruction execution, or accessing elements of an array, or scanning a matrix row by row.
    
    \begin{itemize}
        \item[\textcolor{Green3}{\faIcon{tools}}] \textcolor{Green3}{\textbf{Cache strategy.}} Fetch \textbf{entire blocks}, not single words (e.g., 64-byte lines). Use \textbf{block size $>$ 1 word} to bring adjacent memory into cache.
    \end{itemize}
\end{itemize}

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{question-circle} \textbf{How Caches Exploit Locality}}
\end{flushleft}
With \definition{Cache Block} we refer to the smallest unit of data moved from main memory to cache. It is typically 32, 64 or 128 bytes. It helps bring \textbf{spatial neighbors} into the cache.

\begin{table}[!htp]
    \centering
    \begin{tabular}{@{} l l @{}}
        \toprule
        Locality Type & Cache Mechanism \\
        \midrule
        Temporal    & Keep recently accessed data in cache \\ [.3em]
        Spatial     & Fetch blocks (containing multiple nearby elements) \\
        \bottomrule
    \end{tabular}
\end{table}

\noindent
Most modern cache architectures assume that the programmer writes code that follows locality principles, which i why \textbf{compiler optimizations and programming style} matter.