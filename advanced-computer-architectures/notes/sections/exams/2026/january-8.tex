\section{Exams}

\subsection{2026}

\subsubsection{January 8}

\subsubsection*{Exercise 1A - Scoreboard}

\emph{\textbf{PART A:} Please consider the program in the table be executed on a CPU with dynamic scheduling based on \textbf{SCOREBOARD BASIC SCHEME} with the following assumptions and resources:
\begin{itemize}
    \item \textbf{Check for WAW hazards in the ISSUE stage;}
    \item \textbf{No Forwarding;}
    \item \textbf{2 LOAD/STORE Units (LDU1, LDU2) with latency 3 cycles;}
    \item \textbf{1 FP Unit (FPU1) with latency 3 cycles;}
    \item \textbf{1 ALU/BR Unit (ALU1) with latency 1 cycle.}
\end{itemize}}
\begin{table}[!htp]
    \centering
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{I0:LD \phantom{ }\phantom{ }\phantom{ }\$F2, VB(\$R6)} & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{I1:FADD \phantom{ }\$F4, \$F2, \$F6} &   &   &   &   &   &  \\
        \code{I2:SD \phantom{ }\phantom{ }\phantom{ }\$F4, VA(\$R7)} &   &   &   &   &   &  \\
        \code{I3:LD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R6)} &   &   &   &   &   &  \\
        \code{I4:SD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R7)} &   &   &   &   &   &  \\
        \code{I5:ADDUI \$R6, \$R6, 4} &   &   &   &   &   &  \\
        \code{I6:ADDUI \$R7, \$R7, 4} &   &   &   &   &   &  \\
        \bottomrule
    \end{tabular}
    \caption*{\emph{Where I is the Issue stage, RR is the Read Operands stage, E is the Execute stage, WB is the Write Back stage.}}
\end{table}
\emph{Calculate the \textbf{CPI} of the program and draw the timing diagram showing the status of each instruction at each clock cycle.}

\highspace
\answer The scoreboard (\autopageref{section:scoreboard-dynamic-scheduling-algorithm}) allows out-of-order execution while maintaining program correctness by tracking hazards and resource usage. It is similar to Tomasulo's algorithm but lacks register renaming and forwarding mechanisms. So, \textbf{in-order issue} is enforced, there is no forwarding, and \textbf{out-of-order execution and commit} are allowed (which can introduce WAW and WAR hazards, since there's no register renaming).

\highspace
In a traditional pipeline, the Instruction Decode (ID) stage performs both decoding and operand fetching. But this assumes that operands are always available in the register file during the ID stage. However, with dynamic scheduling, operands might not be ready when an instruction is issued, leading to stalls if we wait for them to be fetched in the ID stage. So, the scoreboard splits the ID stage into two separate stages:
\begin{itemize}
    \item \textbf{Issue Stage}. It decodes the instruction, checks for structural hazards, and enforces in-order issue. If there are structural hazards, the instruction is stalled here.
    \item \textbf{Read Operands Stage}. It waits for the operands to become available. It avoids RAW hazards by deferring opearnd reads until the register is no longer ``reserved'' by an active instruction writing to it. If there are RAW hazards, the instruction is stalled here. Since there is no forwarding, the instruction must wait until the writing instruction completes its Write Back stage.
\end{itemize}
So the \textbf{RAW} hazards are handled in the \textbf{Read Operands stage (RR)}, while \textbf{WAR} hazards are handled in the \textbf{Write Back stage (WB)}, \textbf{WAW} and \textbf{structural} hazards are handled in the \textbf{Issue stage (I)}. See \autoref{subsubsec:scoreboard-control-logic-and-stages} (\autopageref{subsubsec:scoreboard-control-logic-and-stages}) for more details on the scoreboard stages.

\begin{enumerate}
    \setcounter{enumi}{1}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 2
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item We do not consider the first cycle and the instruction \code{I0} because they are already filled in the table.
        \item \code{I1} can be issued in cycle 2 because there are no structural hazards (\code{FPU1} is free) and no WAW hazards (no previous instruction writes to \$F4). So, \code{I1} is in the Issue stage in cycle 2.
        \item Since \code{I1} is issued, it reserves the unit \code{FPU1} and the destination register \$F4.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{FADD \phantom{ }\$F4, \$F2, \$F6}                      & \hl{2} &   &   &   &   & \hl{\texttt{FPU1}} \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VA(\$R7)}    &   &   &   &   &   &  \\
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R6)}    &   &   &   &   &   &  \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R7)}    &   &   &   &   &   &  \\
        \code{ADDUI \$R6, \$R6, 4}                                   &   &   &   &   &   &  \\
        \code{ADDUI \$R7, \$R7, 4}                                   &   &   &   &   &   &  \\
        \bottomrule
    \end{tabular}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 3
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item \code{I1} would like to read its operands in cycle 3, but it cannot because of a RAW hazard on \$F2 (it is being written by \code{I0} which has not yet completed its Write Back stage). So, \code{I1} is stalled until cycle 6 (inclusive), when \code{I0} completes its Write Back stage.
        \item \code{I2} can be issued in cycle 3 because there are no structural hazards (\code{LDU2} is free) and no WAW hazards (no previous instruction writes to \$F4). So, \code{I2} is in the Issue stage in cycle 3.
        \item Since \code{I2} is issued, it reserves the unit \code{LDU2} and the destination register \$F4.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{FADD \phantom{ }\$F4, \$F2, \$F6}                      & 2 &   &   &   & \hl{RAW \texttt{\$F2} \texttt{I0}} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VA(\$R7)}    & \hl{3}  &   &   &   &   & \hl{\texttt{LDU2}} \\
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R6)}    &   &   &   &   &   &  \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R7)}    &   &   &   &   &   &  \\
        \code{ADDUI \$R6, \$R6, 4}                                   &   &   &   &   &   &  \\
        \code{ADDUI \$R7, \$R7, 4}                                   &   &   &   &   &   &  \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 4
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item \code{I1} is still stalled in the Read Operands stage due to the RAW hazard on \$F2.
        \item \code{I2} would like to read its operands in cycle 4, but it cannot because of a RAW hazard on \$F4 (it is being written by \code{I1} which has not yet completed its Write Back stage). So, \code{I2} is stalled until cycle 9 (inclusive), when \code{I1} completes its Write Back stage.
        \item *\code{I3} would like to be issued in cycle 4, but it cannot because of a \textbf{structural hazard} on \code{LDU1} (it is being used by \code{I0}) and a \textbf{WAW hazard} on \$F4 (it is being written by \code{I1} which has not yet completed its Write Back stage). So, \code{I3} is stalled.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{FADD \phantom{ }\$F4, \$F2, \$F6}                      & 2 &   &   &   & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3 &   &   &   & \hl{RAW \texttt{\$F4} \texttt{I1}} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R6)}    &   &   &   &   & \hl{*STR/WAW} &  \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R7)}    &   &   &   &   &   &  \\
        \code{ADDUI \$R6, \$R6, 4}                                   &   &   &   &   &   &  \\
        \code{ADDUI \$R7, \$R7, 4}                                   &   &   &   &   &   &  \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 7
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \setcounter{enumi}{6}
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item Now \code{I1} can read its operands in cycle 7, since the RAW hazard on \$F2 has been resolved (it was written back by \code{I0} in cycle 6). So, \code{I1} is in the Read Operands stage in cycle 7.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{FADD \phantom{ }\$F4, \$F2, \$F6}                      & 2 & \hl{7} &   &   & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3 &   &   &   & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R6)}    &   &   &   &   & STR/WAW &  \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R7)}    &   &   &   &   &   &  \\
        \code{ADDUI \$R6, \$R6, 4}                                   &   &   &   &   &   &  \\
        \code{ADDUI \$R7, \$R7, 4}                                   &   &   &   &   &   &  \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 12
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \setcounter{enumi}{11}
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item We skip to cycle 12, but in cycle 10 the execution of \code{I1} completes and in cycle 11 it writes back its result, resolving the RAW hazard on \$F4 for \code{I2}. So, in cycle 12 \code{I2} can read its operands. So, \code{I2} is in the Read Operands stage in cycle 12.
        \item \code{I3} can now be issued because the WAW hazard on \$F4 has been resolved (it was written back by \code{I1} in cycle 11) and there are no structural hazards (\code{LDU1} is free since \code{I0} completed its Write Back stage in cycle 6). So, \code{I3} is in the Issue stage in cycle 12.
        \item Since \code{I3} is issued, it reserves the unit \code{LDU1} and the destination register \$F4.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1  & 2  & 5  & 6  & & \code{LDU1} \\
        \code{FADD \$F4, \$F2, \$F6}                      & 2  & 7  & 10 & 11 & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3  & 12 &    &    & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 12 &    &    &    & STR/WAW & \hl{\texttt{LDU1}} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VC(\$R7)}    &    &    &    &    & &  \\
        \code{ADDUI \$R6, \$R6, 4}                        &    &    &    &    & &  \\
        \code{ADDUI \$R7, \$R7, 4}                        &    &    &    &    & &  \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 13
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item \code{I3} reads its operands in cycle 13, since there is no RAW hazard on its \$R6 (it is not being written by any active instruction). So, \code{I3} is in the Read Operands stage in cycle 13.
        \item \code{I4} would like to be issued in cycle 13, but it cannot because of a \textbf{structural hazard} on \code{LDU2} (it is being used by \code{I2}).
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1  & 2  & 5  & 6  & & \code{LDU1} \\
        \code{FADD \$F4, \$F2, \$F6}                      & 2  & 7  & 10 & 11 & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3  & 12 &    &    & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 12 & \hl{13} &    &    & STR/WAW & \hl{\texttt{LDU1}} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VC(\$R7)}    &    &    &    &    & \hl{STR \texttt{\$F4} \texttt{I3}} &  \\
        \code{ADDUI \$R6, \$R6, 4}                        &    &    &    &    & &  \\
        \code{ADDUI \$R7, \$R7, 4}                        &    &    &    &    & &  \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 17
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \setcounter{enumi}{16}
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item \code{I3} execution completes in cycle 16 and it writes back its result in cycle 17.
        \item \code{I4} can now be issued because the structural hazard on \code{LDU2} has been resolved (it was freed by \code{I2} which completed its Write Back stage in cycle 16). So, \code{I4} is in the Issue stage in cycle 17.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1  & 2  & 5  & 6  & & \code{LDU1} \\
        \code{FADD \$F4, \$F2, \$F6}                      & 2  & 7  & 10 & 11 & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3  & 12 & 15 & 16 & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 12 & 13 & 16 & \hl{17} & STR/WAW & \texttt{LDU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VC(\$R7)}    & \hl{17} &    &    &    & STR \texttt{\$F4} \texttt{I3} & \hl{\texttt{LDU2}} \\
        \code{ADDUI \$R6, \$R6, 4}                        &    &    &    &    & &  \\
        \code{ADDUI \$R7, \$R7, 4}                        &    &    &    &    & &  \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 18
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item \code{I4} reads its operands in cycle 18, since there is no RAW hazard on its \$R7 (it is not being written by any active instruction). So, \code{I4} is in the Read Operands stage in cycle 18.
        \item \code{I5} can be issued in cycle 18 because there are no structural hazards (\code{ALU1} is free) and no WAW hazards (no previous instruction writes to \$R6). So, \code{I5} is in the Issue stage in cycle 18.
        \item Since \code{I5} is issued, it reserves the unit \code{ALU1} and the destination register \$R6.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1  & 2  & 5  & 6  & & \code{LDU1} \\
        \code{FADD \$F4, \$F2, \$F6}                      & 2  & 7  & 10 & 11 & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3  & 12 & 15 & 16 & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 12 & 13 & 16 & 17 & STR/WAW & \texttt{LDU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VC(\$R7)}    & 17 & \hl{18} &    &    & STR \texttt{\$F4} \texttt{I3} & \texttt{LDU2} \\
        \code{ADDUI \$R6, \$R6, 4}                        & \hl{18} &    &    &    & & \hl{\texttt{ALU1}} \\
        \code{ADDUI \$R7, \$R7, 4}                        &    &    &    &    & &  \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 19
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item \code{I5} reads its operands in cycle 19, since there is no RAW hazard on its \$R6 (it is not being written by any active instruction). So, \code{I5} is in the Read Operands stage in cycle 19.
        \item \code{I6} cannot be issued in cycle 19 because of a \textbf{structural hazard} on \code{ALU1} (it is being used by \code{I5}).
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1  & 2  & 5  & 6  & & \code{LDU1} \\
        \code{FADD \$F4, \$F2, \$F6}                      & 2  & 7  & 10 & 11 & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3  & 12 & 15 & 16 & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 12 & 13 & 16 & 17 & STR/WAW & \texttt{LDU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VC(\$R7)}    & 17 & 18 &    &    & STR \texttt{\$F4} \texttt{I3} & \texttt{LDU2} \\
        \code{ADDUI \$R6, \$R6, 4}                        & 18 & \hl{19} &    &    & & \texttt{ALU1} \\
        \code{ADDUI \$R7, \$R7, 4}                        &  &    &    &    & \hl{STR \texttt{ALU1}} &  \\
        \bottomrule
    \end{tabular}

    \newpage



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 21
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \setcounter{enumi}{20}
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item \code{I4} completes its execution in cycle 20.
        \item \code{I5} writes back its result in cycle 21, freeing up \code{ALU1}. There are no WAR hazards on \$R6 since no active instruction reads from it, so there are no stalls.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1  & 2  & 5  & 6  & & \code{LDU1} \\
        \code{FADD \$F4, \$F2, \$F6}                      & 2  & 7  & 10 & 11 & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3  & 12 & 15 & 16 & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 12 & 13 & 16 & 17 & STR/WAW & \texttt{LDU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VC(\$R7)}    & 17 & 18 & \hl{21} &    & STR \texttt{\$F4} \texttt{I3} & \texttt{LDU2} \\
        \code{ADDUI \$R6, \$R6, 4}                        & 18 & 19 & 20 & \hl{21} & & \texttt{ALU1} \\
        \code{ADDUI \$R7, \$R7, 4}                        &  &    &    &    & STR \texttt{ALU1} &  \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 22
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item \code{I4} writes back its result in cycle 22, freeing up \code{LDU2}. There are no WAR hazards on \$F4 since no active instruction reads from it, so there are no stalls.
        \item \code{I6} can now be issued because the structural hazard on \code{ALU1} has been resolved (it was freed by \code{I5} which completed its Write Back stage in cycle 21) and there are no WAW hazards (no previous instruction writes to \$R7). So, \code{I6} is in the Issue stage in cycle 22.
        \item Since \code{I6} is issued, it reserves the unit \code{ALU1} and the destination register \$R7.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1  & 2  & 5  & 6  & & \code{LDU1} \\
        \code{FADD \$F4, \$F2, \$F6}                      & 2  & 7  & 10 & 11 & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3  & 12 & 15 & 16 & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 12 & 13 & 16 & 17 & STR/WAW & \texttt{LDU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VC(\$R7)}    & 17 & 18 & 21 & \hl{22} & STR \texttt{\$F4} \texttt{I3} & \texttt{LDU2} \\
        \code{ADDUI \$R6, \$R6, 4}                        & 18 & 19 & 20 & 21 & & \texttt{ALU1} \\
        \code{ADDUI \$R7, \$R7, 4}                        & \hl{22} &    &    &    & STR \texttt{ALU1} & \hl{\texttt{ALU1}} \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 25
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \setcounter{enumi}{24}
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item The execution of \code{I6} completes in cycle 24 and it writes back its result in cycle 25.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1  & 2  & 5  & 6  & & \code{LDU1} \\
        \code{FADD \$F4, \$F2, \$F6}                      & 2  & 7  & 10 & 11 & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3  & 12 & 15 & 16 & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 12 & 13 & 16 & 17 & STR/WAW & \texttt{LDU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VC(\$R7)}    & 17 & 18 & 21 & 22 & STR \texttt{\$F4} \texttt{I3} & \texttt{LDU2} \\
        \code{ADDUI \$R6, \$R6, 4}                        & 18 & 19 & 20 & 21 & & \texttt{ALU1} \\
        \code{ADDUI \$R7, \$R7, 4}                        & 22 & 23 & 24 & 25 & STR \texttt{ALU1} & \texttt{ALU1} \\
        \bottomrule
    \end{tabular}
\end{enumerate}
The \textbf{CPI} (Cycles Per Instruction) can be calculated as follows:
\begin{equation*}
    \text{CPI} = \dfrac{\# \, \text{clock cycles}}{\# \, \text{instructions}} = \dfrac{25}{7} \approx 3.57
\end{equation*}

\longline

\subsubsection*{Exercise 1B - Scoreboard}

\emph{\textbf{PART B:} Please consider the introduction of the following \textbf{Optimizations:}
\begin{itemize}
    \item \textbf{Check for WAW postponed to the WRITE BACK phase;}
    \item \textbf{Forwarding;}
\end{itemize}}
\begin{table}[!htp]
    \centering
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{I0:LD \phantom{ }\phantom{ }\phantom{ }\$F2, VB(\$R6)} & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{I1:FADD \phantom{ }\$F4, \$F2, \$F6} &   &   &   &   &   &  \\
        \code{I2:SD \phantom{ }\phantom{ }\phantom{ }\$F4, VA(\$R7)} &   &   &   &   &   &  \\
        \code{I3:LD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R6)} &   &   &   &   &   &  \\
        \code{I4:SD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R7)} &   &   &   &   &   &  \\
        \code{I5:ADDUI \$R6, \$R6, 4} &   &   &   &   &   &  \\
        \code{I6:ADDUI \$R7, \$R7, 4} &   &   &   &   &   &  \\
        \bottomrule
    \end{tabular}
    \caption*{\emph{Where I is the Issue stage, RR is the Read Operands stage, E is the Execute stage, WB is the Write Back stage.}}
\end{table}
\emph{\textbf{Fill the following table} indicating, for each cycle, which instruction is in which stage, and which hazards (if any) are present. Highlight the stalls caused by hazards. Finally, compute the \textbf{CPI} (Cycles Per Instruction) achieved with these optimizations and the \textbf{speedup} with respect to the previous case (without optimizations).}

\highspace
\answer With respect to Exercise 1A, here we have two optimizations: (1) WAW hazard checks are postponed to the Write Back stage, so instructions can be issued even if there is a WAW hazard; (2) Forwarding is implemented, so RAW hazards can be resolved earlier during the Execute stage instead of waiting for the Write Back stage. About forwarding, it simply means that when an instruction produces a result, that result can be forwarded directly to a subsequent instruction that needs it, without waiting for the first instruction to write it back to the register file.

\highspace
In the following tables, we do not report all cycles, but only the ones where the optimizations have an effect.
\begin{enumerate}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 6
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \setcounter{enumi}{5}
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item In the cycle 6, \code{I1} was stalled in the Read Operands stage due to the RAW hazard on \$F2. But now, with forwarding, \code{I1} can read its operand \$F2 directly from the output of \code{I0} during its Execute stage (cycle 5), instead of waiting for \code{I0} to write it back in cycle 6. So, \code{I1} can read its operands in cycle 6. It anticipates the Write Back of \code{I0} by one cycle.
        \item \code{I3} cannot be issued in cycle 6 because of a \textbf{structural hazard} on \code{LDU1} (it is being used by \code{I0}). However, there is no WAW hazard on \$F4 because WAW checks are postponed to the Write Back stage. This will allow \code{I3} to be issued earlier in a later cycle.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{FADD \phantom{ }\$F4, \$F2, \$F6}                      & 2 & \hl{6} &   &   & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3 &   &   &   & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R6)}    &   &   &   &   & \hl{STR \texttt{LDU1}} &  \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R7)}    &   &   &   &   &   &  \\
        \code{ADDUI \$R6, \$R6, 4}                                   &   &   &   &   &   &  \\
        \code{ADDUI \$R7, \$R7, 4}                                   &   &   &   &   &   &  \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 7
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item Thanks to WAW checks being postponed to the Write Back stage, \code{I3} can now be issued in cycle 7, even if there is a WAW hazard on \$F4 with \code{I1}. So, \code{I3} is in the Issue stage in cycle 7.
        \item Since \code{I3} is issued, it reserves the unit \code{LDU1} and the destination register \$F4.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{FADD \phantom{ }\$F4, \$F2, \$F6}                      & 2 & 6 &   &   & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3 &   &   &   & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R6)}    & \hl{7} &   &   &   & STR \texttt{LDU1} & \hl{\texttt{LDU1}} \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R7)}    &   &   &   &   &   &  \\
        \code{ADDUI \$R6, \$R6, 4}                                   &   &   &   &   &   &  \\
        \code{ADDUI \$R7, \$R7, 4}                                   &   &   &   &   &   &  \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 8
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item \code{I3} reads its operands in cycle 8, since there is no RAW hazard on its \$R6 (it is not being written by any active instruction). So, \code{I3} is in the Read Operands stage in cycle 8.
        \item \code{I4} cannot be issued in cycle 8 because of a \textbf{structural hazard} on \code{LDU2} (it is being used by \code{I2}). \code{I4} chooses the FU \code{LDU2} because is the least recently used among the two load/store units.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{FADD \phantom{ }\$F4, \$F2, \$F6}                      & 2 & 6 &   &   & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3 &   &   &   & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 7 & \hl{8} &   &   & STR \texttt{LDU1} & \texttt{LDU1} \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R7)}    &   &   &   &   & \hl{STR \texttt{LDU2}} &  \\
        \code{ADDUI \$R6, \$R6, 4}                                   &   &   &   &   &   &  \\
        \code{ADDUI \$R7, \$R7, 4}                                   &   &   &   &   &   &  \\
        \bottomrule
    \end{tabular}
    \newpage



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 10
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \setcounter{enumi}{9}
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item \code{I1} completes its execution in cycle 9 and it writes back its result in cycle 10.
        \item \code{I2} can now read its operands in cycle 10, since there is forwarding and it can get the value of \$F4 directly from the output of \code{I1} during its Write Back stage (cycle 10), instead of waiting for \code{I1} to write it back in cycle 11. So, \code{I2} is in the Read Operands stage in cycle 10.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{FADD \phantom{ }\$F4, \$F2, \$F6}                      & 2 & 6 & 9  & \hl{10} & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3 & \hl{10} &   &   & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 7 & 8 &   &   & STR \texttt{LDU1} & \texttt{LDU1} \\
        \code{SD \phantom{ }\phantom{ }\phantom{ }\$F4, VC(\$R7)}    &   &   &   &   & STR \texttt{LDU2} &  \\
        \code{ADDUI \$R6, \$R6, 4}                                   &   &   &   &   &   &  \\
        \code{ADDUI \$R7, \$R7, 4}                                   &   &   &   &   &   &  \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 13
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \setcounter{enumi}{12}
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item \code{I3} completes its execution in cycle 11 and it writes back its result in cycle 12. There is a WAW hazard on \$F4 with \code{I1}, but since WAW checks are postponed to the Write Back stage, \code{I3} can write back its result in cycle 12 without stalls (\code{I1} already wrote back in cycle 10, so there is no conflict).
        \item \code{I4} can now read its operands in cycle 13, since there is no more structural hazard on \code{LDU2} (it was freed by \code{I2} which completed its Execute stage in cycle 12). So, \code{I4} is in the Read Operands stage in cycle 13.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{FADD \$F4, \$F2, \$F6}                      & 2 & 6 & 9  & 10 & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3 & 10 & \hl{13} &   & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 7 & 8 & 11 & 12 & STR \texttt{LDU1} & \texttt{LDU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VC(\$R7)}    & \hl{13} &   &   &   & STR \texttt{LDU2} & \hl{\texttt{LDU1}} \\
        \code{ADDUI \$R6, \$R6, 4}                                   &   &   &   &   &   &  \\
        \code{ADDUI \$R7, \$R7, 4}                                   &   &   &   &   &   &  \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 14
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item \code{I2} completes its execution in cycle 13 and it writes back its result in cycle 14.
        \item \code{I4} reads its operands in cycle 14, since there is no RAW hazard on its \$R6 (it is not being written by any active instruction). So, \code{I4} is in the Read Operands stage in cycle 14.
        \item \code{I5} starts its Issue stage in cycle 14. There are no structural hazards.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{FADD \$F4, \$F2, \$F6}                      & 2 & 6 & 9  & 10 & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3 & 10 & 13 & \hl{14} & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 7 & 8 & 11 & 12 & STR \texttt{LDU1} & \texttt{LDU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VC(\$R7)}    & 13 & \hl{14} &   &   & STR \texttt{LDU2} & \texttt{LDU1} \\
        \code{ADDUI \$R6, \$R6, 4}                        & \hl{14} &   &   &   &   & \hl{\texttt{ALU1}} \\
        \code{ADDUI \$R7, \$R7, 4}                        &   &   &   &   &   &  \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 15
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item \code{I5} reads its operands in cycle 15, since there are no RAW hazards on its source register \$R6 (it is not being written by any active instruction). So, \code{I5} is in the Read Operands stage in cycle 15.
        \item \code{I6} cannot be issued in cycle 15 because of a \textbf{structural hazard} on \code{ALU1} (it is being used by \code{I5}).
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{FADD \$F4, \$F2, \$F6}                      & 2 & 6 & 9  & 10 & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3 & 10 & 13 & 14 & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 7 & 8 & 11 & 12 & STR \texttt{LDU1} & \texttt{LDU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VC(\$R7)}    & 13 & 14 &   &   & STR \texttt{LDU2} & \texttt{LDU1} \\
        \code{ADDUI \$R6, \$R6, 4}                        & 14 & \hl{15} &   &   &   & \texttt{ALU1} \\
        \code{ADDUI \$R7, \$R7, 4}                        &   &   &   &   & \hl{STR \texttt{ALU1}} &  \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 18
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item \code{I4} completes its execution in cycle 17 and it writes back its result in cycle 18.
        \item \code{I6} can now be issued because the structural hazard on \code{ALU1} has been resolved (it was freed by \code{I5} which completed its Execute stage in cycle 17). So, \code{I6} is in the Issue stage in cycle 18.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{FADD \$F4, \$F2, \$F6}                      & 2 & 6 & 9  & 10 & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3 & 10 & 13 & 14 & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 7 & 8 & 11 & 12 & STR \texttt{LDU1} & \texttt{LDU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VC(\$R7)}    & 13 & 14 & 17 & \hl{18} & STR \texttt{LDU2} & \texttt{LDU1} \\
        \code{ADDUI \$R6, \$R6, 4}                        & 14 & 15 & 16 & 17 &   & \texttt{ALU1} \\
        \code{ADDUI \$R7, \$R7, 4}                        & \hl{18} &   &   &   & STR \texttt{ALU1} & \hl{\texttt{ALU1}} \\
        \bottomrule
    \end{tabular}



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % Cycle 21
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \setcounter{enumi}{20}
    \item \textbf{Cycle \theenumi}
    \begin{itemize}
        \item The execution of \code{I6} completes in cycle 20 and it writes back its result in cycle 21.
    \end{itemize}
    \begin{tabular}{@{} l c c c c c c @{}}
        \toprule
        \textbf{Instruction} & \textbf{I} & \textbf{RR} & \textbf{E} & \textbf{WB} & \textbf{Hazards Type} & \textbf{Unit} \\
        \midrule
        \code{LD \phantom{ }\phantom{ }\$F2, VB(\$R6)}    & 1 & 2 & 5 & 6 & & \code{LDU1} \\
        \code{FADD \$F4, \$F2, \$F6}                      & 2 & 6 & 9  & 10 & RAW \texttt{\$F2} \texttt{I0} & \texttt{FPU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VA(\$R7)}    & 3 & 10 & 13 & 14 & RAW \texttt{\$F4} \texttt{I1} & \texttt{LDU2} \\
        \code{LD \phantom{ }\phantom{ }\$F4, VC(\$R6)}    & 7 & 8 & 11 & 12 & STR \texttt{LDU1} & \texttt{LDU1} \\
        \code{SD \phantom{ }\phantom{ }\$F4, VC(\$R7)}    & 13 & 14 & 17 & 18 & STR \texttt{LDU2} & \texttt{LDU1} \\
        \code{ADDUI \$R6, \$R6, 4}                        & 14 & 15 & 16 & 17 &   & \texttt{ALU1} \\
        \code{ADDUI \$R7, \$R7, 4}                        & 18 & 19 & 20 & 21 & STR \texttt{ALU1} & \texttt{ALU1} \\
        \bottomrule
    \end{tabular}
\end{enumerate}
The \textbf{CPI} (Cycles Per Instruction) can be calculated as follows:
\begin{equation*}
    \text{CPI} = \dfrac{\# \, \text{clock cycles}}{\# \, \text{instructions}} = \dfrac{21}{7} = 3
\end{equation*}
The \textbf{speedup} with respect to the previous case (without optimizations) is:
\begin{equation*}
    \text{Speedup} = \dfrac{\text{CPI}_{\text{old}}}{\text{CPI}_{\text{new}}} = \dfrac{3.57}{3} \approx 1.19
\end{equation*}
So, with these optimizations, we achieve a speedup of approximately 1.19 times compared to the original implementation without optimizations, about a 19\% performance improvement.

\longline

\subsubsection*{Exercise 2 - VLIW Scheduling}

\emph{Let's consider the following LOOP code, where \textbf{\texttt{\$Ri}} are integer registers and \textbf{\texttt{\$Fi}} are floating-point registers.}
\begin{lstlisting}
FOR:    LD $F2, VB ($R6)    # I0
        FADD $F4, $F2, $F6  # I1
        SD  $F4, VA ($R7)   # I2
        LD  $F4, VC ($R6)   # I3
        SD  $F4, VC ($R7)   # I4
        FADD $F8, $F8, $F8  # I5
        ADDUI $R6, $R6, 4   # I6
        ADDUI $R7, $R7, 4   # I7
        BNE $R7, $R8, FOR   # I8
\end{lstlisting}
\emph{Given a \textbf{3-issue VLIW} machine with \textbf{fully pipelined functional units:}
\begin{itemize}
    \item \textbf{1 Memory Unit with 3 cycles latency}
    \item \textbf{1 FP ALUs with 3 cycles latency}
    \item \textbf{1 Integer ALU with 1 cycle latency to next Int/FP/L/S \& 2 cycles latency to next Branch}
\end{itemize}
The branch is completed with 1 cycle delay slot (branch solved in ID stage). \textbf{No branch prediction}. In the Register File, it is possible to read and write at the same address at the same clock cycle. Considering one iteration of the loop, complete the following table by using the \textbf{list-based scheduling} (do NOT introduce any software pipelining, loop unrolling and modifications to loop indexes) on the 3-issue VLIW machine including the BRANCH DELAY SLOT. Please do not write in NOPs.}

\newpage

\noindent
\emph{Let's complete the following table indicating, for each cycle, which instructions are issued in the VLIW:}
\begin{table}[!htp]
    \centering
    \begin{tabular}{@{} l | c | c | c @{}}
        \toprule
        & \textbf{Integer ALU} & \textbf{Memory Unit} & \textbf{FP Unit} \\
        \midrule
        \textbf{C1} & & \code{LD \$F2, VB(\$R6)} & \\
        \textbf{C2} & & & \\
        \textbf{C3} & & & \\
        \textbf{C4} & & & \\
        \textbf{C5} & & & \\
        \textbf{C6} & & & \\
        \textbf{C7} & & & \\
        \textbf{C8} & & & \\
        \textbf{C9} & & & \\
        \textbf{C10} & & & \\
        \textbf{C11} & & & \\
        \textbf{C12} & & & \\
        \textbf{C13} & & & \\
        \textbf{C14} & & & \\
        \textbf{C15} & & & \\
        \bottomrule
    \end{tabular}
\end{table}
\emph{And finally, answer the following questions:
\begin{itemize}
    \item How long is the critical path for a single iteration?
    \item What performance did you achieve in FP ops per cycles?
    \item How much is the code efficiency for a single iteration?
    \item What CPI did you achieve?
\end{itemize}}

\highspace
\answer To perform list-based scheduling for the given loop code on a 3-issue VLIW machine, we first need to draw the dependency graph for the instructions (see \autopageref{subsubsection: Dependence Graph and Critical Path}). In the following list, we indicate the dependencies between instructions:
\begin{itemize}
    \item RAW:
    \begin{itemize}
        \item \code{I1} depends on \code{I0} (reads \$F2 written by \code{I0})
        \item \code{I2} depends on \code{I1} (reads \$F4 written by \code{I1})
        \item \code{I4} depends on \code{I3} (reads \$F4 written by \code{I3})
        \item \code{I8} depends on \code{I7} (reads \$R7 written by \code{I7})
    \end{itemize}
    \item WAR and WAW:
    \begin{itemize}
        \item \code{I3} has a WAW hazard with \code{I1} (both write to \$F4)
        \item \code{I3} has a WAR hazard with \code{I2} (writes to \$F4 read by \code{I2})
        \item \code{I6} has a WAR hazard with \code{I3} (writes to \$R6 read by \code{I3})
        \item \code{I7} has a WAR hazard with \code{I4} (writes to \$R7 read by \code{I4}) and \code{I2} (writes to \$R7 read by \code{I2})
    \end{itemize}
\end{itemize}
Using this information, we draw the dependency graph below.

\begin{center}
    \begin{tikzpicture}[node distance=1.7cm, >=stealth]
        % Nodes
        \node[circle, draw] (I0) {$I_{0}$};
        \node[circle, draw, right=of I0] (I5) {$I_{5}$};
        \node[circle, draw, below=of I0] (I1) {$I_{1}$};
        \node[circle, draw, below=of I1] (I2) {$I_{2}$};
        \node[circle, draw, right=of I2] (I3) {$I_{3}$};
        \node[circle, draw, right=of I3] (I6) {$I_{6}$};
        \node[circle, draw, below=of I2] (I7) {$I_{7}$};
        \node[circle, draw, below=of I3] (I4) {$I_{4}$};
        \node[circle, draw, below=of I7] (I8) {$I_{8}$};

        % % Dashed Edges
        \draw[dashed, ->] (I1) -- (I3) node[midway, sloped, above, inner sep=2pt] {\texttt{WAW \$F4}};
        \draw[dashed, ->] (I2) -- (I3) node[midway, sloped, above, inner sep=2pt] {\texttt{WAR \$F4}};
        \draw[dashed, ->] (I2) -- (I7) node[midway, left, inner sep=2pt] {\texttt{WAR \$R7}};
        \draw[dashed, ->] (I3) -- (I6) node[midway, sloped, above, inner sep=2pt] {\texttt{WAR \$R6}};
        \draw[dashed, ->] (I4) -- (I7) node[midway, sloped, above, inner sep=2pt] {\texttt{WAR \$R7}};

        % % Solid Edges
        \draw[->] (I0) -- (I1);
        \draw[->] (I1) -- (I2);
        \draw[->] (I3) -- (I4);
        \draw[->] (I7) -- (I8);
    \end{tikzpicture}
\end{center}
And the table is completed simply by scheduling the instructions while respecting the dependencies and the functional unit constraints (waiting for RAW hazards to be resolved and avoiding structural hazards):
\begin{table}[!htp]
    \centering
    \begin{tabular}{@{} l | c | c | c @{}}
        \toprule
        & \textbf{Integer ALU} & \textbf{Memory Unit} & \textbf{FP Unit} \\
        \midrule
        \textbf{C1}  & & \texttt{LD \$F2, VB(\$R6)} & \texttt{FADD \$F8, \$F8, \$F8} \\
        \textbf{C2}  & & & \\
        \textbf{C3}  & & & \\
        \textbf{C4}  & & & \texttt{FADD \$F4, \$F2, \$F6} \\
        \textbf{C5}  & & & \\
        \textbf{C6}  & & & \\
        \textbf{C7}  & & \texttt{SD \$F4, VA (\$R7)} & \\
        \textbf{C8}  & \texttt{ADDUI \$R6, \$R6, 4} & \texttt{LD \$F4, VC (\$R6)} & \\
        \textbf{C9}  & & & \\
        \textbf{C10} & & & \\
        \textbf{C11} & \texttt{ADDUI \$R7, \$R7, 4} & \texttt{SD \$F4, VC (\$R7)} & \\
        \textbf{C12} &  & & \\
        \textbf{C13} & \texttt{BLT \$R7, \$R8, FOR} & & \\
        \textbf{C14} & \texttt{(delay)} & & \\
        \textbf{C15} & & & \\
        \bottomrule
    \end{tabular}
\end{table}

\noindent
The \texttt{BLT} instruction is placed in cycle 13 because the previous instruction (\code{I7}) takes 2 cycles instead of 1 to prepare for the branch, as specified in the problem statement. Additionally, a delay slot must be added in cycle 14 after the branch instruction, as required by the exercise.

\highspace
Now, we can answer the questions:
\begin{itemize}
    \item \emph{How long is the critical path for a single iteration?} It corresponds to the last instruction to complete its Write Back stage: \code{I8} in cycle 14. Therefore, the critical path is \textbf{14 cycles}.
    
    \item \emph{What performance did you achieve in FP ops per cycles?} There are 2 floating-point operations (\code{I1} and \code{I5}) completed in 14 cycles. Therefore, the performance is:
    \begin{equation*}
        \text{FP ops/cycle} = \dfrac{2 \, \text{ FP ops}}{14 \, \text{cycles}} \approx 0.14 \text{ FP ops/cycle}
    \end{equation*}

    \item \emph{How much is the code efficiency for a single iteration?} Code efficiency quantifies how well the issued instructions utilize the available issue slots. In our case, we have a 3-issue VLIW machine and we issued 9 instructions in 14 cycles (cycles C2, C3, C5, C6, C9, C10, and C12 are empty). Therefore, the code efficiency is:
    \begin{equation*}
        \text{Code Efficiency} = \dfrac{\text{Instruction Count}}{\text{\# cycles} \cdot \text{Issue Width}} = \dfrac{9}{14 \cdot 3} \approx 0.21
    \end{equation*}

    \item \emph{What CPI did you achieve?} The CPI (Cycles Per Instruction) can be calculated as follows:
    \begin{equation*}
        \text{CPI} = \dfrac{\# \, \text{clock cycles}}{\text{Instruction Count}} = \dfrac{14}{9} \approx 1.56
    \end{equation*}
\end{itemize}

\newpage

\subsubsection*{Exercise 3 - MESI Protocol}

\emph{Let's consider the following access patterns on a dual processor system with a direct-mapped, write-back cache with one cache block per processor and a two cache block memory. Assume the \textbf{MESI protocol} is used, with \textbf{write-back} caches, \textbf{write-allocate}, and \textbf{write-invalidate} of other caches. Please complete the following table:}

\begin{table}[!htp]
    \centering
    \begin{tabular}{@{} l | l | p{5em} | p{5em} | p{4em} | p{4em} @{}}
        \toprule
        \textbf{T} & \textbf{After Operation} & \textbf{P0 cache block state} & \textbf{P1 cache block state} & \textbf{Memory at block 0 up to date?} & \textbf{Memory at block 1 up to date?} \\
        \midrule
        0   & \texttt{P0: read block 1}  & Excl(1) & Invalid & Yes & Yes \\[.3em]
        1   & \texttt{P1: write block 0} & & & & \\[.3em]
        2   & \texttt{P0: write block 0} & & & & \\[.3em]
        3   & \texttt{P1: read block 0}  & & & & \\[.3em]
        4   & \texttt{P0: read block 1}  & & & & \\[.3em]
        5   & \texttt{P1: read block 1}  & & & & \\[.3em]
        6   & \texttt{P0: read block 1}  & & & & \\[.3em]
        7   & \texttt{P1: write block 1} & & & & \\[.3em]
        8   & \texttt{P0: read block 0}  & & & & \\[.3em]
        9   & \texttt{P1: write block 1} & & & & \\[.3em]
        10  & \texttt{P1: write block 1} & & & & \\[.3em]
        11  & \texttt{P0: read block 1}  & & & & \\[.3em]
        12  & \texttt{P1: write block 1} & & & & \\[.3em]
        13  & \texttt{P0: write block 1} & & & & \\[.3em]
        14  & \texttt{P1: read block 1}  & & & & \\
        \bottomrule
    \end{tabular}
\end{table}

\noindent
\answer The MESI protocol (\autopageref{section: mesi-protocol}) is a cache coherence protocol used in multiprocessor systems to maintain consistency between caches. The four states in the MESI protocol are Modified (M, a cache line that has been modified and is different from main memory), Exclusive (E, a cache line that is present only in one cache and is the same as main memory), Shared (S, a cache line that may be present in multiple caches and is the same as main memory), and Invalid (I, a cache line that is not valid). Also, the cache uses:
\begin{itemize}
    \item \textbf{Write-Back} policy: data is written to main memory only when it is evicted from the cache. In MESI, this means that a cache line in the Modified state must be written back to memory before being invalidated or replaced.
    \item \textbf{Write-Allocate} policy: on a write miss, the cache allocates a new cache line and loads the data from memory before performing the write.
    \item \textbf{Write-Invalidate} policy: when a processor writes to a cache line, it invalidates that line in other caches to maintain coherence.
\end{itemize}

\newpage

\begin{table}[!htp]
    \centering
    \begin{tabular}{@{} l | l | p{5em} | p{5em} | p{4em} | p{4em} @{}}
        \toprule
        \textbf{T} & \textbf{After Operation} & \textbf{P0 cache block state} & \textbf{P1 cache block state} & \textbf{Memory at block 0 up to date?} & \textbf{Memory at block 1 up to date?} \\
        \midrule
        0   & \texttt{P0: read block 1}  & \texttt{Excl(1)}  & \texttt{Invalid}   & \textcolor{Green3}{\faIcon{check}} Yes & \textcolor{Green3}{\faIcon{check}} Yes \\[.3em]
        1   & \texttt{P1: write block 0} & \texttt{Excl(1)}  & \texttt{Mod(0)}    & \textcolor{Red2}{\faIcon{times}} No    & \textcolor{Green3}{\faIcon{check}} Yes \\[.3em]
        2   & \texttt{P0: write block 0} & \texttt{Mod(0)}   & \texttt{Invalid}   & \textcolor{Red2}{\faIcon{times}} No    & \textcolor{Green3}{\faIcon{check}} Yes \\[.3em]
        3   & \texttt{P1: read block 0}  & \texttt{Shr(0)}   & \texttt{Shr(0)}    & \textcolor{Green3}{\faIcon{check}} Yes & \textcolor{Green3}{\faIcon{check}} Yes \\[.3em]
        4   & \texttt{P0: read block 1}  & \texttt{Excl(1)}  & \texttt{Excl(0)}   & \textcolor{Green3}{\faIcon{check}} Yes & \textcolor{Green3}{\faIcon{check}} Yes \\[.3em]
        5   & \texttt{P1: read block 1}  & \texttt{Shr(1)}   & \texttt{Shr(1)}    & \textcolor{Green3}{\faIcon{check}} Yes & \textcolor{Green3}{\faIcon{check}} Yes \\[.3em]
        6   & \texttt{P0: read block 1}  & \texttt{Shr(1)}   & \texttt{Shr(1)}    & \textcolor{Green3}{\faIcon{check}} Yes & \textcolor{Green3}{\faIcon{check}} Yes \\[.3em]
        7   & \texttt{P1: write block 1} & \texttt{Invalid}  & \texttt{Mod(1)}    & \textcolor{Green3}{\faIcon{check}} Yes & \textcolor{Red2}{\faIcon{times}} No \\[.3em]
        8   & \texttt{P0: read block 0}  & \texttt{Excl(0)}  & \texttt{Mod(1)}    & \textcolor{Green3}{\faIcon{check}} Yes & \textcolor{Red2}{\faIcon{times}} No \\[.3em]
        9   & \texttt{P1: write block 1} & \texttt{Excl(0)}  & \texttt{Mod(1)}    & \textcolor{Green3}{\faIcon{check}} Yes & \textcolor{Red2}{\faIcon{times}} No \\[.3em]
        10  & \texttt{P1: write block 1} & \texttt{Excl(0)}  & \texttt{Mod(1)}    & \textcolor{Green3}{\faIcon{check}} Yes & \textcolor{Red2}{\faIcon{times}} No \\[.3em]
        11  & \texttt{P0: read block 1}  & \texttt{Shr(1)}   & \texttt{Shr(1)}    & \textcolor{Green3}{\faIcon{check}} Yes & \textcolor{Green3}{\faIcon{check}} Yes \\[.3em]
        12  & \texttt{P1: write block 1} & \texttt{Invalid}  & \texttt{Mod(1)}    & \textcolor{Green3}{\faIcon{check}} Yes & \textcolor{Red2}{\faIcon{times}} No \\[.3em]
        13  & \texttt{P0: write block 1} & \texttt{Mod(1)}   & \texttt{Invalid}   & \textcolor{Green3}{\faIcon{check}} Yes & \textcolor{Red2}{\faIcon{times}} No \\[.3em]
        14  & \texttt{P1: read block 1}  & \texttt{Shr(1)}   & \texttt{Shr(1)}    & \textcolor{Green3}{\faIcon{check}} Yes & \textcolor{Green3}{\faIcon{check}} Yes \\
        \bottomrule
    \end{tabular}
\end{table}

\noindent
Where \texttt{Mod(x)} indicates that the cache block x is in the Modified state, \texttt{Excl(x)} indicates that the cache block x is in the Exclusive state, \texttt{Shr(x)} indicates that the cache block x is in the Shared state, and \texttt{Invalid} indicates that the cache block is in the Invalid state. For reference on state transitions, see the complete finite state machine (FSM) for the MESI protocol on \autopageref{fig: mesi-finite-state-machine}.

\newpage

\subsubsection*{Question 1: Cache Coherence Protocols}

\emph{Let's consider the SNOOPING and the DIRECTORY-BASED protocols used to maintain the cache coherence in modern multiprocessor. Answer the following questions:}
\begin{itemize}
    \item \emph{Explain the main characteristics of each protocol.}
    
    \answer (see \autopageref{sec:snooping-bus-based-protocols} for snooping protocols and \autopageref{sec:directory-based-protocols} for directory-based protocols)
    \begin{itemize}
        \item \important{Snooping Protocols} are \textbf{cache coherence protocols based on broadcast communication}. Each cache controller \textbf{monitors\break (snoops)} all coherence transactions issued on a \textbf{shared communication medium} (typically a bus or a broadcast interconnect). The main characteristics include:
        \begin{itemize}
            \item \textbf{All coherence requests are broadcast} to all caches.
            \item Each cache independently checks whether it has a copy of the block.
            \item Coherence actions (invalidate / update) are taken locally.
            \item No centralized state is maintained.
        \end{itemize}
        \item \important{Directory-Based Protocols} are \textbf{cache coherence protocols\break based on centralized or distributed directories} that \textbf{track the sharing state of each memory block}. For each memory block, a \textbf{directory entry} records:
        \begin{itemize}
            \item Which processors currently cache the block.
            \item The coherence state (e.g., shared, exclusive).
        \end{itemize}
        Main characteristics include:
        \begin{itemize}
            \item Coherence requests are \textbf{sent to the directory}, not broadcast.
            \item The directory \textbf{selectively notifies only the caches involved}.
            \item Supports \textbf{point-to-point communication}.
            \item Eliminates unnecessary broadcasts.
        \end{itemize}
    \end{itemize}


    \item \emph{For which type of multiprocessor architecture is each protocol suitable for?}

    \answer
    \begin{itemize}
        \item \important{Snooping protocol} is suitable for \textbf{small-scale centralized shared\break -memory multiprocessors (SMPs)}. In these architectures, processors share a \textbf{single logical memory}, a \textbf{broadcast interconnect} (like a bus) is available, and the number of processors is relatively small (typically up to 16 or 32). The use of broadcast allows every cache to observe coherence requests, but the approach \textbf{does not scale} due to increasing traffic and contention on the bus as the number of processors increases.
        
        \item \important{Directory-based protocol} is suitable for \textbf{large-scale distributed shared-memory multiprocessors}, including \textbf{NUMA and distributed shared-memory systems}. In these architectures, the memory is \textbf{physically distributed}, a coherence is enforced using \textbf{point-to-point messages}, and the directory tracks which processors cache each memory block. This approach avoids broadcast and therefore \textbf{scales well with the number of processors}. It is suitable for systems with a large number of processors (hundreds or thousands) where snooping would be impractical due to high communication overhead.
    \end{itemize}


    \item \emph{What are the \textbf{main benefits} of each protocol?}

    \answer
    \begin{itemize}
        \item \important{Benefits of Snooping Protocols}:
        \begin{itemize}
            \item \textbf{Simplicity}, since no centralized structure is required.
            \item \textbf{Low coherence latency}, thanks to immediate broadcast visibility.
            \item \textbf{Fast detection of coherence events}, as every cache observes all requests.
            \item \textbf{Low protocol overhead} for small-scale systems.
        \end{itemize}
        In short, snooping is \hl{simple}, \hl{low latency}, \hl{broadcast visibility}, and \hl{good for small systems}.
        
        \item \important{Benefits of Directory-Based Protocols}:
        \begin{itemize}
            \item \textbf{High scalability}, since broadcast is avoided.
            \item \textbf{Reduced coherence traffic}, due to targeted point-to-point messages.
            \item \textbf{Efficient bandwidth usage}, especially in large systems.
            \item \textbf{Support} for \textbf{physically distributed memory} architectures.
        \end{itemize}
        In short, directory-based protocols are \hl{scalable}, \hl{no broadcast}, \hl{targeted communication}, and \hl{good for large/NUMA systems}.
    \end{itemize}


    \item \emph{Explain the \textbf{two types} of Snooping protocol depending on what happens on a write operation.}
    
    \answer (see \autopageref{sec:write-invalidate-vs-write-update})
    \begin{itemize}
        \item \important{Write-Invalidate Protocol}. When a processor writes to a shared cache block, it \textbf{invalidates all other cached copies} of that block. Mechanism:
        \begin{enumerate}
            \item The writing processor issues an \textbf{invalidate request} on the bus.
            \item All other caches \textbf{snoop} the bus and \textbf{invalidate} their local copies of the block if they have it.
            \item The writing processor then obtains \textbf{exclusive ownership} and can update the block locally.
        \end{enumerate}
        This approach allows \textbf{multiple readers but only one writer}. Subsequent writes by the same processor do \textbf{not generate bus traffic} and reduces coherence traffic for repeated writes.
        \item \important{Write-Update (or Write-Broadcast) Protocol}. When a processor writes to a shared cache block, it \textbf{broadcast the new data value} to all other caches. Mechanism:
        \begin{enumerate}
            \item The writing processor places the \textbf{updated value} on the bus.
            \item All caches \textbf{snoop} the write.
            \item Caches that hold the block \textbf{update their local copy} with the new value.
        \end{enumerate}
        This approach allows to keep all cached copies \textbf{consistent at all times}, but generates \textbf{bus traffic on every write}. It is suitable when shared data are frequently read by many processors after each write.
    \end{itemize}


    \item \emph{What are the possible \textbf{coherence states} of a block in the home directory and the meaning of the \textbf{sharer bits}?}

    \answer (see \autopageref{ques:what-is-stored-in-directory}) In a \textbf{directory-based cache coherence protocol}, each memory block has an associated \textbf{directory entry} stored at its \textbf{home node}. The directory entry records the \textbf{coherence state of the block} and a set of \textbf{sharer bits}.
    
    \important{Coherence states in the home directory.} A directory typically maintains \textbf{three coherence states} for each block:
    \begin{enumerate}
        \item \textbf{Uncached (U)} (or \textbf{Invalid}). The block is \textbf{not cached in any processor} and the memory holds the only valid copy.
        \item \textbf{Shared (S)}. The block is cached by \textbf{multiple processors} and all cached copies are \textbf{read-only}. The memory contains an up-to-date copy.
        \item \textbf{Modified (M)}. The block is cached by \textbf{exactly one processor} and that processor has \textbf{write permission}. The memory may be \textbf{out-of-date} if the cached copy has been modified.
    \end{enumerate}

    \important{Sharer bits.} The \textbf{sharer bits} are a bit-vector associated with each directory entry. Each bit corresponds to a processor (or cache) in the system. The meaning of the sharer bits is:
    \begin{itemize}
        \item A bit is set to \textbf{1} if the corresponding processor currently \textbf{caches a copy} of the block.
        \item A bit is set to \textbf{0} if the corresponding processor does \textbf{not cache} the block.
    \end{itemize}
    The sharer bits allow the directory to send \textbf{targeted invalidations} and \textbf{update or recall messages} only to the processors that currently cache the block, avoiding broadcast communication. So, these bits are essential for scalability (avoiding broadcast), point-to-point communication, and efficiency in large multiprocessor systems.
\end{itemize}