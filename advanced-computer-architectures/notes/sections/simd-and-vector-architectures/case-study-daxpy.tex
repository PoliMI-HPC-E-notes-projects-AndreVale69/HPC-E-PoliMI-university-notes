\subsection{Case Study: DAXPY}

\definition{DAXPY (Double-precision A$\cdot$X Plus Y)} computes the operation:
\begin{equation}
    Y[i] = a \cdot X[i] + Y[i]
\end{equation}
For each element of vectors $X$ and $Y$, with $a$ a scalar constant. This is a \textbf{very common kernel in linear algebra}, part of the \textbf{BLAS (Basic Linear Algebra Subprograms)} library, widely used in scientific computing.

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{question-circle} \textbf{Why is DAXPY a good case study?}}
\end{flushleft}
\begin{enumerate}
    \item \textbf{Simplicity}. It has a very regular structure: one multiply, one add, per element. It avoids complex dependencies, so it is perfect to isolate the effects of vectorization.
    \item \textbf{Representative of real workloads}. DAXPY is a \textbf{building block in linear algebra and machine learning}. Appears in the \textbf{Linpack benchmark}, which is used to rank supercomputers.
    \item \textbf{Highlights the difference between scalar and vector execution}
    \begin{itemize}
        \item \textbf{Scalar MIPS version}: $\approx$ 578 instructions for 64 elements (plus stalls).
        \item \textbf{Vector VMIPS version}: just 6 instructions for the whole loop!
    \end{itemize}
    Shows how \textbf{instruction count, loop overhead, and pipeline stalls} disappear with vectorization.
    \item \textbf{Perfect to introduce performance metrics}. Lets us compare execution time in \textbf{clock cycles}:
    \begin{itemize}
        \item Scalar: $\approx$ 600 cycles.
        \item Vector (without chaining): $\approx$ 320 cycles.
        \item Vector (with chaining): $\approx$ 192 cycles.
    \end{itemize}
    Later, we can extend to \textbf{multiple lanes, convoys, chimes}, etc.
\end{enumerate}
The DAXPY case study is \textbf{didactic} because it connects the abstract concepts (VRF, VFUs, chaining, convoys) with a concrete \textbf{numerical example}. It shows \textbf{why SIMD/Vector machines are powerful} (fewer instructions, fewer stalls, higher throughput) and provides a \textbf{benchmark loop} to quantify speedups when new architectural features (chaining, multiple lanes, strip mining, predication) are introduced. Finally, it's the \textbf{entry point} to understanding how to reason about \textbf{vector performance models}.