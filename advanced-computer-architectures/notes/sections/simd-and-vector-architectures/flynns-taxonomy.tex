\subsection{Flynn's taxonomy}

Michael Flynn (1966) classified computers based on how many \textbf{instruction streams} and \textbf{data streams} they handle simultaneously:
\begin{itemize}
    \item \definition{SISD (Single Instruction, Single Data)}. \hl{One instruction stream, one data stream}. It's a classic uniprocessor model with a scalar RISC pipeline, an in-order MIPS, or even an out-of-order (OoO) superscalar, because despite multiple instructions being issued per cycle, there's still one program counter and one stream of instructions.

    \item \definition{SIMD (Single Instruction, Multiple Data)}. \hl{One instruction stream, many data streams}. A control unit broadcasts the same instruction to many Processing Elements (PEs). Each PE has its own registers (and sometimes local memory) but all execute the \emph{same} op on different data. Includes:
    \begin{itemize}
        \item Classic vector processors (Cray, VMIPS model).
        \item Packed-SIMD extensions in CPUs (MMX, SSE, AVX).
        \item GPUs in their SIMD ``warp'' execution style.
    \end{itemize}

    \item \definition{MISD (Multiple Instruction, Single Data)}. Rarely used in real systems. Hypothetical model where \hl{multiple different instructions operate on the same data stream}. Mostly academic (pipeline reliability systems sometimes cited).

    \item \definition{MIMD (Multiple Instruction, Multiple Data)}. \hl{Multiple independent processors, each with its own PC, instruction stream, and data.} This is the model of \textbf{multicore CPUs, clusters, distributed-memory systems}. Threads can be tightly or loosely coupled.
\end{itemize}

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{question-circle} \textbf{Where vector machines sit}}
\end{flushleft}
Vectors are \textbf{one form of SIMD}. We issue \textbf{one vector instruction}; \textbf{each element in the vector register is processed in lockstep across functional units}. The programmer still sees \textbf{one PC, one instruction stream}, but the datapath replicates across elements. This makes vector machines the \textbf{canonical, textbook example of SIMD}.

\highspace
\begin{flushleft}
    \textcolor{Red2}{\faIcon{exclamation-triangle} \textbf{Practical clarification}}
\end{flushleft}
There's often confusion:
\begin{itemize}
    \item \textbf{Superscalar CPUs (ILP)}: not SIMD in Flynn's sense, because although they issue multiple instructions, they all belong to \textbf{the same stream} (still SISD).

    \textcolor{Green3}{\faIcon{question-circle} \textbf{Why are superscalar CPUs SISD and not SIMD?}} \textbf{Flynn's classification is about \emph{streams}, not width}. Flynn cares about how many \textbf{independent instruction streams} and \textbf{independent data streams} the machine has. A \textbf{superscalar} CPU still fetches from a \textbf{single program counter (PC)}, meaning \textbf{one instruction stream}. Even if it can issue 4, 6, or 8 instructions per cycle, those instructions all come from the \emph{same stream}.

    \highspace
    In SIMD, we fetch \textbf{one instruction} (\texttt{ADDV V1, V2, V3}), and that instruction \textbf{applies to many data elements at once} (\texttt{V1[i] = V2[i] + V3[i]} for all \texttt{i}). In superscalar, we fetch multiple \textbf{distinct instructions}, each working on their own operands, not one instruction replicated over multiple data. So:
    \begin{itemize}
        \item SIMD is \textbf{parallelism across data elements (DLP)}.
        \item Superscalar is \textbf{parallelism across independent instructions\break (ILP)}.
    \end{itemize}
    \item \textbf{Multithreaded/multicore (TLP)}: that's MIMD, not SIMD. Each\break thread has its own instruction stream.
    \item \textbf{SIMD/vector/GPU}: add data-level parallelism, one PC controlling\break many elements.
\end{itemize}
The taxonomy is coarse, but it helps us distinguish between OoO ILP and DLP SIMD. For us: \textbf{in Flynn's taxonomy, vector processors are SIMD}.