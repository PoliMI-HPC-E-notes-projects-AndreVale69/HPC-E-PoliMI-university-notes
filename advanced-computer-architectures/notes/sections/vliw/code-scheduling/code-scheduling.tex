\subsection{Code Scheduling}

As we saw on page \hqpageref{Code Scheduling}, Code Scheduling is the process of rearranging program instructions to maximize parallelism during execution. The \hl{primary goal} of \definition{Code Scheduling} is to \textbf{statically reorder instructions} within object code in such a way that:
\begin{itemize}[label=\textcolor{Green3}{\faIcon{check}}]
    \item Execution time is minimized.
    \item Semantic correctness is preserved.
\end{itemize}
In simple terms, we want the program to run as \textbf{fast as possible without changing what it computes}. This is essential because in architectures like VLIW (Very Long Instruction Word), the hardware doesn't handle instruction reordering dynamically. Instead, the \textbf{compiler is fully responsible} for finding parallelism and deciding the scheduling.

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{question-circle} \textbf{Motivation in VLIW Architectures}}
\end{flushleft}
In VLIW architectures, the \textbf{responsibility of exploiting} instruction-level parallelism (\textbf{ILP}) is \textbf{shifted from the hardware to the compiler}. \hl{This shift implies} several things:
\begin{itemize}
    \item The \textbf{hardware is simpler}: no complex dynamic scheduling (like Tomasulo or Scoreboarding).
    \item \textbf{Parallel instructions are issued together} as part of a wide instruction word.
    \item \textbf{Each instruction} slot in a VLIW word maps to a specific \textbf{functional unit}.
\end{itemize}
\textcolor{Green3}{\faIcon{question-circle} \textbf{Why do we need scheduling in this context?}} Because a VLIW machine expects \textbf{parallel instructions to be packed statically} in the same bundle. If the compiler fails to schedule efficiently, the result is many \textbf{NOPs} and a waste of hardware resources.

\highspace
\begin{flushleft}
    \textcolor{Red2}{\faIcon{exclamation-triangle} \textbf{Semantic Correctness and Performance}}
\end{flushleft}
It's not enough to just reorder instructions for performance. We must also preserve:
\begin{itemize}
    \item \textbf{True data dependencies (RAW)}, instructions must respect the order of reads after writes.
    \item Avoid introducing errors by violating:
    \begin{itemize}
        \item \textbf{Anti-dependencies (WAR)}
        \item \textbf{Output dependencies (WAW)}
    \end{itemize}
\end{itemize}
The scheduler (compiler) must:
\begin{itemize}[label=\textcolor{Green3}{\faIcon{check}}]
    \item Carefully \textbf{analyze the dependency graph} of the instructions.
    \item \textbf{Reorder only when it's safe.}
    \item \textbf{Possibly apply renaming} or other transformations to eliminate false dependencies.
\end{itemize}