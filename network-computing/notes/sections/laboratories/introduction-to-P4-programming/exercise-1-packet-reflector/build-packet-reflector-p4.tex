\paragraph{Build \texttt{packet\_reflector.p4}}

Now that we have the topology ready, we can start writing the P4 program for our packet reflector. We will complete the implementation of P4 program step by step, following the TODOs outlined in the exercise. Each TODO will guide us through the necessary components of the P4 program, starting with defining the headers and moving on to parsing, processing, and finally emitting packets.
\begin{enumerate}
    \item \important{TODO 1: Define headers (Ethernet)}
    \begin{lstlisting}[style=p4style]
/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>

/*
 * H E A D E R S
 */

struct metadata {
    /* empty */
}

/* TODO 1: define headers */\end{lstlisting}
    Our switch receives a packet as \textbf{raw bytes}. To do anything meaningful (swap MACs, check EtherType, forward), P4 needs a \textbf{typed view} of those bytes. So TODO 1 is where we define:
    \begin{enumerate}
        \item \textbf{Which headers exist};
        \item \textbf{Which fields they contain};
        \item How the program will \textbf{refer to them later}.
    \end{enumerate}
    In P4, a \texttt{header} is a special type that represents a \textbf{protocol header that may or may not be present} in a packet. It has an \textbf{implicit validity bit} (valid/invalid). The parser will ``extract'' it, which makes it \textbf{valid} and fills its fields from the packet. Later stages (ingress/egress) can safely check/use it.

    For our packet reflector, we only need to define the Ethernet header:
    \begin{lstlisting}[style=p4style]
header ethernet_t { ... }\end{lstlisting}
    It means that our program will only be able to parse and process the Ethernet header. If we receive a packet with an IP header, for example, we won't be able to parse it and won't be able to access its fields.

    \textcolor{Green3}{\faIcon{question-circle} \textbf{Which fields should we define in the Ethernet header?}} The exercise provides a hint: ``the format of the Ethernet header is 6 bytes for the destination MAC, 6 bytes for the source MAC, and 2 bytes for the EtherType''. So we need to define three fields: \texttt{dstAddr}, \texttt{srcAddr}, and \texttt{etherType}. The first two are 48 bits (6 bytes) long, while the last one is 16 bits (2 bytes) long. We can use the built-in type \texttt{bit} to define them:
    \begin{lstlisting}[style=p4style]
header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}\end{lstlisting}
    We also need to define a \texttt{headers} struct that contains all the headers we want to parse. In our case, we only have one header (Ethernet), so it will be simple:
    % add color to ethernet_t
    \begin{lstlisting}[style=p4style, morekeywords={[2]{ethernet_t}}]
struct headers {
    ethernet_t ethernet;
}\end{lstlisting}


    \item \important{TODO 2: parse ethernet header}
    \begin{lstlisting}[style=p4style, morekeywords={[2]{ethernet_t, headers, metadata}}]
/*
 * P A R S E R
 */
parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

      /* TODO 2: parse ethernet header */

}\end{lstlisting}
    In \texttt{v1model}, the parser is a \textbf{state machine} that:
    \begin{itemize}
        \item Reads from \texttt{packet\_in packet}
        \item ``Extracts'' headers into \texttt{hdr}
        \item Decides what state to go to next
    \end{itemize}
    For this exercise, we only need \textbf{one header} (Ethernet), so the parser can be minimal. We can start in a state called \texttt{start}, where we will try to extract the Ethernet header. If the extraction is successful, we will transition to a state called \texttt{accept}, which means that we have successfully parsed the packet and can move on to processing it. If the extraction fails (e.g., if the packet is too short), we can transition to a state called \texttt{reject}, which means that we will drop the packet.
    \begin{lstlisting}[style=p4style, morekeywords={[2]{ethernet_t, headers, metadata}}]
parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}\end{lstlisting}
    Since we only have one header, we don't need to check the EtherType or anything else to decide what to parse next. We can simply try to extract the Ethernet header and move on.

    After parsing, we will have a valid \texttt{hdr.ethernet} header and we can access its fields in the ingress/egress processing stages.

    \textbf{Note}: in \texttt{v1model}, the ``end of parsing'' is called \texttt{accept} state, and the ``parsing failed'' state is called \texttt{reject}. We don't need to explicitly define them if we don't want to do anything special in those cases. If we want to drop packets that fail parsing, we can simply transition to \texttt{reject} and the switch will automatically drop them.


    \newpage


    \item \important{TODO 3: define packet reflector logic}
    \begin{lstlisting}[style=p4style, morekeywords={[2]{ethernet_t, headers, metadata}}]
/*
 * I N G R E S S   P R O C E S S I N G
 */
control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {

    /* TODO 3: define packet reflector logic */
}\end{lstlisting}
    The ingress control is where we will implement the main logic of our packet reflector. We will:
    \begin{itemize}
        \item Read parsed headers from \texttt{hdr.ethernet.*},
        \item Swap the source and destination MAC addresses.
        \item Set the output port to the same port where the packet came from (i.e., reflect it back).
    \end{itemize}
    In \texttt{v1model}, the final output decision is typically done via:
    \begin{equation*}
        \texttt{standard\_metadata.egress\_spec}
    \end{equation*}
    Which specifies the output port. The code to swap the MAC addresses would look like this:
    \begin{lstlisting}[style=p4style, morekeywords={[2]{ethernet_t, headers, metadata}}]
bit<48> originalAddr;
originalAddr = hdr.ethernet.srcAddr;
hdr.ethernet.srcAddr = hdr.ethernet.dstAddr;
hdr.ethernet.dstAddr = originalAddr;\end{lstlisting}
    And to reflect the packet back to the input port, we can use:
    \begin{lstlisting}[style=p4style, morekeywords={[2]{ethernet_t, headers, metadata}}]
standard_metadata.egress_spec = standard_metadata.ingress_port;\end{lstlisting}
    We put it all together in the \texttt{MyIngress} control:
    \begin{lstlisting}[style=p4style, morekeywords={[2]{ethernet_t, headers, metadata}}]
control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply {
        bit<48> originalAddr;
        originalAddr = hdr.ethernet.srcAddr;
        hdr.ethernet.srcAddr = hdr.ethernet.dstAddr;
        hdr.ethernet.dstAddr = originalAddr;
        standard_metadata.egress_spec = standard_metadata.ingress_port;
    }
}\end{lstlisting}
    The \texttt{apply} block is where we put the actual processing logic. In this case, we simply swap the MAC addresses and set the output port to reflect the packet back.


    \item \important{TODO 4: deparse header}
    \begin{lstlisting}[style=p4style, morekeywords={[2]{ethernet_t, headers, metadata}}]
/*
 * D E P A R S E R
 */
control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        /* TODO 4: deparse header */
	}
}\end{lstlisting}
    The deparser is responsible for taking the processed headers and emitting them back as raw bytes to be sent out of the switch. In our case, we only have one header (Ethernet), so we just need to emit it in the correct order. The code would look like this:
    \begin{lstlisting}[style=p4style, morekeywords={[2]{ethernet_t, headers, metadata}}]
control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}\end{lstlisting}
    The \texttt{packet.emit()} function takes care of serializing the header fields back into raw bytes. Since we only have one header, we just emit it directly. If we had multiple headers, we would need to emit them in the correct order (e.g., Ethernet first, then IP, etc.).
\end{enumerate}
The final P4 program will be a combination of all the components we defined in the TODOs, and it will implement a simple packet reflector that swaps the source and destination MAC addresses and reflects the packet back to the input port.
\begin{center}
    \qrcode{https://gist.github.com/AndreVale69/f462128ecac5a918087f582bfe1b3242#file-packet_reflector-p4}
    \hspace{1cm}
    \href{https://gist.github.com/AndreVale69/f462128ecac5a918087f582bfe1b3242#file-packet_reflector-p4}{View the code on GitHub}
\end{center}