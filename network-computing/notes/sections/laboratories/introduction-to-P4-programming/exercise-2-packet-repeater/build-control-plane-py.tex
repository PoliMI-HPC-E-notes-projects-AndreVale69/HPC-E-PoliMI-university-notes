\paragraph{Build \texttt{control\_plane.py}}

The \texttt{control\_plane.py} file is responsible for installing the forwarding rules on the switch. It uses the P4Runtime API to communicate with the switch and configure it according to the P4 program we have written.

\highspace
The skeleton code provided in \texttt{control\_plane.py} is as follows:
\begin{lstlisting}[language=Python]
#!/usr/bin/env python3

from p4utils.utils.helper import load_topo
from p4utils.utils.sswitch_p4runtime_API import SimpleSwitchP4RuntimeAPI


topo = load_topo('topology.json')
controllers = {}

for switch, data in topo.get_p4rtswitches().items():
    controllers[switch] = SimpleSwitchP4RuntimeAPI(
        data['device_id'],
        data['grpc_port'],
        p4rt_path=data['p4rt_path'],
        json_path=data['json_path']
    )

controller = controllers['s1']                        

# TODO: write the forwarding rules for the switch
controller.table_add('repeater', 'forward', ['1'], ['2'])\end{lstlisting}
\begin{itemize}
    \item The code starts by importing the necessary modules and loading the topology from the \texttt{topology.json} file. The JSON file is generated by the P4-Utils when the topology is started, and it contains all the information about the switch names, their device IDs, gRPC ports, and paths to the compiled artifacts.
    

    \item We then create a dictionary called \texttt{controllers} to store the P4Runtime API instances for each switch. In other words, it maps each switch name to an instance of \texttt{SimpleSwitchP4RuntimeAPI}, which is initialized with the corresponding device ID, gRPC port, and paths to the P4Runtime and JSON files. This allows us to easily interact with each switch later on when we need to install rules.


    \item We connect to each P4Runtime switch by creating an instance of \texttt{SimpleSwitchP4RuntimeAPI} for each switch defined in the topology. The function \texttt{get\_p4rtswitches} returns all switches that were created with \texttt{addP4RuntimeSwitch} (so they speak P4Runtime); for each one, we create a connection object that knows how to reach the switch (gRPC port) and what pipeline it is running (paths to the compiled P4 artifacts).
    
    \highspace
    So after this loop, if we have 3 switches, we will have 3 entries in the \texttt{controllers} dictionary, each one ready to send commands to its respective switch.


    \item  Finally, we pick the switch controller for \texttt{s1} and store it in the variable \texttt{controller}. This is the switch we will be configuring in this exercise, as it is the one that will be responsible for forwarding packets between the hosts.
\end{itemize}
About the TODO, it asks us to write the forwarding rules for the switch. This means that we need to use the P4Runtime API to install the appropriate entries in the match-action tables defined in our P4 program. It can be done by calling methods on the \texttt{controller} object, called \texttt{controller.table\_add} to add an entry to the table. In our case, we will need to add rules to the \texttt{repeater} table that we defined in the P4 program, which matches on the ingress port and decides whether to forward or drop the packet. For example, if we want to forward packets coming from port 1 to port 2, we would add a rule like this:
\begin{lstlisting}[language=Python]
controller.table_add('repeater', 'forward', ['1'], ['2'])\end{lstlisting}
This command tells the switch that if a packet arrives on port 1, it should execute the \texttt{forward} action with the parameter 2, which means to forward the packet to port 2. Now we write the P4 program that defines the \texttt{repeater} table and the corresponding actions.
