\paragraph{Build \texttt{vlan\_handler.p4}}

Now that we have defined the behavior we want to implement, we can start building the P4 program. The main file is \texttt{vlan\_handler.p4}, which will contain the logic for parsing, validating, forwarding, and encapsulating/decapsulating packets based on VLAN tags. We study each section of the P4 program in detail:
\begin{itemize}
    \item \important{Headers}. We need to define two headers: the Ethernet header (which is always present) and the VLAN header 802.1Q (which is only present for tagged packets). The Ethernet header contains source and destination MAC addresses, while the VLAN header contains the VLAN ID and other fields.
    \begin{lstlisting}[style=p4style, morekeywords={[2]{ethernet_t, vlan_tag_t, headers, metadata}}]
/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>

/*
 * H E A D E R S
 */

struct metadata {
}

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header vlan_tag_t {
    bit<3>  pcp;
    bit<1>  dei;
    bit<12> vid;
    bit<16> etherType;
}

struct headers {
    ethernet_t ethernet;
    vlan_tag_t vlan;
}\end{lstlisting}

    
    \item \important{Parser: detect ``tagged vs untagged''}. The parser does exactly the VLAN detection logic:
    \begin{enumerate}
        \item Always extract Ethernet;
        \item And if Ethernet type (\texttt{etherType}) is \texttt{0x8100}, extract the VLAN tag as well.
    \end{enumerate}
    \begin{lstlisting}[style=p4style, morekeywords={[2]{ethernet_t, vlan_tag_t, headers, metadata}}]
/*
 * P A R S E R
 */

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            0x8100: parse_vlan;
            default: accept;
        }
    }

    state parse_vlan {
        packet.extract(hdr.vlan);
        transition accept;
    }
}\end{lstlisting}

    
    \item \important{Ingress: enforce policy $+$ do forwarding $+$ add/remove tags}.
    \begin{lstlisting}[style=p4style, morekeywords={[2]{ethernet_t, vlan_tag_t, headers, metadata}}]
/*
 * I N G R E S S   P R O C E S S I N G
 */

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {

    // ----- Actions -----

    action drop() {
        mark_to_drop(standard_metadata);
    }

    action forward(bit<9> port) {
        standard_metadata.egress_spec = port;
    }

    // Encapsulate: add VLAN header and send to port 1
    action add_vlan_hdr(bit<12> vid) {
        // VLAN header becomes present
        hdr.vlan.setValid();

        // Set VLAN tag fields
        hdr.vlan.pcp = 0;
        hdr.vlan.dei = 0;
        hdr.vlan.vid = vid;

        // Preserve the "inner" EtherType
        // inside the VLAN header
        hdr.vlan.etherType = hdr.ethernet.etherType;

        // Ethernet EtherType becomes TPID for VLAN
        hdr.ethernet.etherType = 0x8100;

        // Always return to h1 on port 1
        standard_metadata.egress_spec = 1;
    }

    // ----- Tables -----

    // From h1 (tagged): VID -> output port (2/3/4).
    // Default -> 2.
    table vlan_table {
        key = {
            hdr.vlan.vid : exact;
        }
        actions = {
            forward;
            drop;
        }
        // Exercise requirement: unknown VID defaults to h2
        // => port 2
        default_action = forward(2);
        size = 128;
    }

    // From h2/h3/h4 (untagged):
    // ingress port -> VLAN to add + send to port 1
    table port_to_vlan {
        key = {
            standard_metadata.ingress_port : exact;
        }
        actions = {
            add_vlan_hdr;
            drop;
        }
        default_action = drop();
        size = 16;
    }

    apply {
        bit<9> in_port = standard_metadata.ingress_port;
        bool tagged = hdr.vlan.isValid();

        // -------------------------
        // Enforce tagging policy
        // -------------------------

        // Port 1 MUST be tagged
        if (in_port == 1 && !tagged) {
            drop();
            return;
        }

        // Ports 2/3/4 MUST be untagged
        if (in_port != 1 && tagged) {
            drop();
            return;
        }

        // -------------------------
        // Direction A: from port 1
        // -------------------------
        if (in_port == 1) {
            // Decide output port based on VLAN ID
            vlan_table.apply();

            // If we're sending to ports 2/3/4,
            // we must strip VLAN before delivery
            // (h2/h3/h4 should receive untagged frames)
            if (
                standard_metadata.egress_spec != 1 &&
                hdr.vlan.isValid()
            ) {
                // Restore Ethernet EtherType
                // to the inner value
                hdr.ethernet.etherType = hdr.vlan.etherType;

                // Remove VLAN header
                hdr.vlan.setInvalid();
            }
            return;
        }

        // -------------------------
        // Direction B: from ports 2/3/4
        // -------------------------
        // Packet is untagged here (enforced above).
        // Add VLAN header based on ingress port and forward to port 1.
        port_to_vlan.apply();
    }
}\end{lstlisting}
    The ingress pipeline is where the main logic of the VLAN handler lives.
    \begin{enumerate}
        \item \textbf{Actions: the ``operations'' the switch can perform on packets}. We need to define actions for:
        \begin{itemize}
            \item \textbf{Dropping packets}: the \texttt{drop()} action marks the packet to be dropped by setting a flag in the standard metadata.
            \item \textbf{Forwarding packets}: the \texttt{forward(port)} action sets the egress port in the standard metadata, which tells the switch where to send the packet.
            \item \textbf{Adding a VLAN header}: the \texttt{add\_vlan\_hdr(vid)} action constructs a VLAN header with the given VLAN ID, sets the appropriate fields, and prepares the packet to be sent to port 1.
        \end{itemize}

        \item \textbf{Tables: what the control plane can program to make decisions}. We need two tables:
        \begin{itemize}
            \item \texttt{vlan\_table} (VID $\to$ output port): this table is used for packets coming from port 1 (tagged). It looks at the VLAN ID and decides which port to forward to (2/3/4). If the VLAN ID is not found, it defaults to forwarding to port 2 (\texttt{h2}).
            \item \texttt{port\_to\_vlan} (ingress port $\to$ VLAN ID to add): this table is used for packets coming from ports 2/3/4 (untagged). It looks at the ingress port and decides which VLAN ID to add before sending to port 1. If the ingress port is not found, it drops the packet.
        \end{itemize}

        \item \textbf{Apply block: the logic that processes each packet}. The \texttt{apply} block contains the actual logic that is executed for each packet:
        \begin{itemize}
            \item First, it checks the ingress port and whether the packet is tagged to enforce the VLAN tagging policy (drop if port 1 is untagged, or if ports 2/3/4 are tagged).
            \item Then, if the packet is from port 1 (tagged), it applies the\break \texttt{vlan\_table} to decide where to forward it, and if it's going to ports 2/3/4, it removes the VLAN tag before delivery.
            \item If the packet is from ports 2/3/4 (untagged), it applies the \texttt{port\_\break{}to\_vlan} table to add the appropriate VLAN tag and forward it to port 1.
        \end{itemize}
    \end{enumerate}


    \item \important{Deparser: how to emit the packet out}. The deparser is responsible for emitting the packet out of the switch. In our case, we need to emit the Ethernet header, and if the VLAN header is valid, we emit it as well. The order of emission is important: if the VLAN header is present, it must come after the Ethernet header, otherwise the packet would be malformed.
    \begin{lstlisting}[style=p4style, morekeywords={[2]{ethernet_t, vlan_tag_t, headers, metadata}}]
/*
 * D E P A R S E R
 */

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.vlan);
    }
}\end{lstlisting}
\end{itemize}
The code is available here:
\begin{center}
    \qrcode{https://gist.github.com/AndreVale69/1a21e2f6ffdc0737d54ac175c04f4a22}
    \hspace{1cm}
    \href{https://gist.github.com/AndreVale69/1a21e2f6ffdc0737d54ac175c04f4a22}{View Code on GitHub}
\end{center}
To test the P4 program, we can use the same commands as in the previous exercise:
\begin{itemize}
    \item Run the network topology with the command:
    \begin{lstlisting}
sudo python3 network_topo.py\end{lstlisting}
    \item After running the network, we open two terminals for the hosts and run the control plane script in the main terminal. So in the mininet CLI, we run:
    \begin{lstlisting}
mininet> xterm h1 h2 h3 h4\end{lstlisting}
    This will open four xterm windows, one for each host.

    \item In the host \texttt{h2} terminal, we run the command to listen for incoming packets:
    \begin{lstlisting}
python3 receive.py\end{lstlisting}
    This will start a simple Python script that listens for packets on the host \texttt{h2}.

    \item In the host \texttt{h1} terminal, we run the command to send a packet:
    \begin{lstlisting}
python3 send.py -d 10.0.0.2 -v 2 -m "Hello H2, I'm H1!"\end{lstlisting}
    This will send a packet from \texttt{h1} to \texttt{h2} with the specified destination IP, VLAN ID, and message.

    If everything is set up correctly, we should see the message ``\emph{Hello H2!}'' appear in the terminal of \texttt{h2}, indicating that the packet was successfully forwarded by the switch according to the rules we installed in the control plane.

    \begin{figure}[!htp]
        \centering
        \includegraphics[width=\textwidth]{img/vlan-result.png}
        \caption{Testing the VLAN handler: \texttt{h1} sends a tagged packet to \texttt{h2}, which receives it successfully after the switch processes the VLAN tag.}
    \end{figure}
\end{itemize}