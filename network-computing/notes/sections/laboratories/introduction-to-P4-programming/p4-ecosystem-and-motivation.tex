\subsubsection{P4 ecosystem and motivation}

Traditional networks are built with \textbf{fixed-function devices}, such as routers and switches, which have predefined functionalities determined by their hardware design. This rigidity limits the ability to adapt to new protocols or requirements without replacing the hardware. Supporting new protocols requires new hardware \emph{or} slow firmware updates, which can be costly and time-consuming. Network operators have \textbf{little control} over packet processing, which hinders innovation and flexibility.

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon[regular]{lightbulb} \textbf{Core motivation behind P4}}
\end{flushleft}
P4 (Programming Protocol-Independent Packet Processors) was designed to answer one question: ``\emph{how should packets be processed?}'' instead of ``\emph{which protocol does this switch support?}''. So the motivation is \textbf{protocol independence}, \textbf{programmability of the data plane}, and \textbf{fast innovation without changing hardware}.

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{question-circle} \textbf{Where P4 fits in the ecosystem}}
\end{flushleft}
P4 is part of a broader shift toward \textbf{network programmability}.
\begin{itemize}
    \item Control Plane $\to$ decides policies (routing, rules) and manages the network.
    \item Data Plane $\to$ executes packet processing (P4 lives here).
\end{itemize}
P4 does \textbf{not} replace routing protocols, controllers, or orchestration tools. Instead, it gives them \textbf{more expressive power}.

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{tools} \textbf{Typical P4 ecosystem components}}
\end{flushleft}
A P4-based system usually includes:
\begin{enumerate}
    \item \textbf{P4 program}: Describes how packets are processed.
    \item \textbf{P4 compiler}: Translates the program for a specific target.
    \item \textbf{P4 target}: Switch, SmartNIC, or software switch that runs the compiled program.
    \item \textbf{Control plane}: Installs table entries (e.g., via P4Runtime).
\end{enumerate}
The key idea is that the \textbf{data plane is programmable}, but the \textbf{control plane still decides policies}.