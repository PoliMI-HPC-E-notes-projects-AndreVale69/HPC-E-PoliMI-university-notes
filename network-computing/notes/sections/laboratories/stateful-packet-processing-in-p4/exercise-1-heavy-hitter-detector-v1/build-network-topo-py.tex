\paragraph{Build \texttt{network\_topo.py}}

The syntax of \texttt{network\_topo.py} is always the same, and the only thing that changes is the number of hosts, switches, and links. In Exercise 1, we will build a simple topology with:
\begin{itemize}
    \item Four \textbf{hosts} (\texttt{h1}, \texttt{h2}, \texttt{h3}, \texttt{h4}).
    \item One P4 \textbf{switch} (\texttt{s1}).
    \item A \textbf{control switch} that programs the P4 switch at runtime using\break \texttt{P4RuntimeSwitch}.
\end{itemize}
\begin{lstlisting}[language=Python]
from p4utils.mininetlib.network_API import NetworkAPI

network = NetworkAPI()

# Network general options
network.setLogLevel('info')
network.setCompiler(p4rt=True)
network.execScript('python control_plane.py', reboot=True)

# Network definition
switch = network.addP4RuntimeSwitch('s1')
host1 = network.addHost('h1')
host2 = network.addHost('h2')
host3 = network.addHost('h3')
host4 = network.addHost('h4')
network.setP4Source('s1', 'hdd_v1.p4')

# Assignment strategy
network.addLink(host1, switch)
network.addLink(host2, switch)
network.addLink(host3, switch)
network.addLink(switch, host4)

# Nodes general options
network.l2()
network.enablePcapDumpAll()
network.enableLogAll()
network.enableCli()
network.startNetwork()\end{lstlisting}
The code is self-explanatory, and all the questions about the specific lines are already answered in the previous exercises. The only difference is that we have more hosts and links, and we set a different P4 source file for the switch. The behavior of the network will be defined by the P4 program and the control plane, which we will see in the next sections.