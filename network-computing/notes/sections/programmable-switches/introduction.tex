\section{Programmable Switches}

\subsection{Introduction}

In the past, \textbf{network switches were designed with fixed-function\break pipelines}. These switches could process packets extremely fast, but their internal logic was essentially ``hardcoded'' by hardware vendors. This meant that the functionality they provided, things like Ethernet switching, IP routing, and basic ACLs, was rigid and \textbf{difficult to extend or modify}.

\highspace
However, as networks evolved and application demands grew more complex, the limitations of these fixed-function switches became apparent. There was a \textbf{growing need for flexibility at the data plane}, the part of the switch responsible for real-time packet processing. Network operators started to ask: \emph{what if we could \emph{program} the switch behavior instead of relying on vendors to update the hardware every time we needed new features?} This is where the concept of \textbf{programmable switches comes into play}.

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{question-circle} \textbf{Why Programmability?}}
\end{flushleft}
The \textbf{motivation} behind programmable switches stems from the \textbf{increasing complexity and dynamism of modern networks}. Today's infrastructures must support custom protocols for emerging technologies like IoT, 5G, and machine learning. They must also be able to adapt quickly to changing requirements, detect and mitigate threats in real-time, and perform network telemetry and monitoring with high granularity.

\highspace
With \textbf{traditional switches}, making such changes \textbf{often meant waiting\break months} (or even years) for new hardware to be designed and released. In contrast, \textbf{programmable switches allow network behavior to be redefined using software}, even after deployment. This ability to program the forwarding logic gives networks a software-like agility that was previously unthinkable at the data plane level.

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{balance-scale} \textbf{Control Plane vs Data Plane}}
\end{flushleft}
To understand the significance of programmable switches, it's useful to recall the basic architecture of a network device. Typically, a \textbf{switch is divided into two major components}:
\begin{itemize}
    \item The \definition{Control Plane}, which is \textbf{responsible for}:
    \begin{itemize}
        \item Computing routing tables;
        \item Handling management tasks;
        \item Making decisions about where traffic should go.
    \end{itemize}
    \item The \definition{Data Plane}, which is \textbf{responsible for}:
    \begin{itemize}
        \item \textbf{Forwarding packets} at line rate, based on the decisions made by the control plane.
    \end{itemize}
\end{itemize}
Traditionally, most of the innovation in networking happened in the control plane, for example, with Software-Defined Networking (SDN), which centralized and virtualized control logic (section \ref{section: Software Defined Networking (SDN)}, page \pageref{section: Software Defined Networking (SDN)}). But the data plane remained fixed and closed.

\highspace
\textbf{Programmable switches} shift this dynamic. They open up the data plane to innovation, \textbf{allowing developers to express forwarding behavior in a high-level language such as P4}. This means we can now rethink how packets are processed inside the switch itself.

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{microchip} \textbf{The Rise of PISA}}
\end{flushleft}
A key enabler of this shift is the \definition{Protocol-Independent Switch Architecture (PISA)}. Proposed by Barefoot Networks (later acquired by Intel), \textbf{PISA is a flexible hardware architecture that allows the structure of the switch pipeline to be configured by software}. Using PISA, one can \textbf{define new packet formats, parsing rules, match-action logic, and even custom metadata fields}, all \hl{using a high-level language like P4}.

\highspace
With PISA-based switches, it is no longer necessary to hardcode support for every protocol in silicon. Instead, \textbf{developers can define how packets are handled at runtime}. This brings about a level of protocol independence and reconfigurability that was previously reserved for general-purpose processors, but with the performance and parallelism needed to operate at terabit speeds.