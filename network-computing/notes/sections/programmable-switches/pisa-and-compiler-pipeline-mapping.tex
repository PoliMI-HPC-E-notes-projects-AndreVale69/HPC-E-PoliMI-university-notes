\subsection{PISA and Compiler Pipeline Mapping}

\definition{Protocol-Independent Switch Architecture (PISA)} is the \textbf{hardware abstraction} used by modern programmable switches (e.g., Barefoot Tofino). The idea behind PISA is simple but powerful: instead of building fixed-function blocks into hardware (e.g., IP routers, firewalls), \textbf{expose a generic pipeline of programmable stages}, and \textbf{let software define what each stage does}.

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{microchip} \textbf{PISA Architecture}}
\end{flushleft}
A PISA switch consists of the following main components:
\begin{itemize}
    \item \important{Parser}. \textbf{Extracts} packet \textbf{headers} and \textbf{creates} a structured \textbf{representation} (called a \definition{Packet Header Vector}, or PHV). The PHV contains the keys for the match-Action units.
    
    \item \important{Multiple Match-Action Stages}. A pipeline of identical stages. Each stage:
    \begin{itemize}
        \item Matches on some fields (using SRAM or TCAM)
        \item Executes simple actions (via Arithmetic Logic Units - ALUs)
        \item Modifies the PHV (e.g., changing a header field, setting a drop flag)
    \end{itemize}
    
    \item \important{Deparser}. \textbf{Reassembles the packet} by combining the (possibly modified) headers and payload. Every packet flows through this pipeline, so the logic must be fully deterministic and parallelizable.
\end{itemize}

\begin{figure}[!htp]
    \centering
    \includegraphics[width=\textwidth]{img/pisa-arch.pdf}
    \caption{PISA architecture.}
\end{figure}

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{question-circle} \textbf{Why use a pipelined architecture instead of a single processor?}}
\end{flushleft}
A naive design would use \textbf{one CPU} to handle every packet: perform all lookups (routing, ACLs, NAT, etc.), apply all rules. But this would require an \textbf{unrealistically high frequency} to process billions of packets per second.

\highspace
Just like in CPUs, we divide the processing into \textbf{stages}, each with: local memory (tables), local ALU, fixed resources. Each packet moves one stage forward per clock cycle, so we can \textbf{process many packets in parallel}.

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{check-circle} \textbf{Protocol Independence}}
\end{flushleft}
One of \textbf{PISA}'s most powerful features is that the chip \textbf{knows nothing in advance}.
\begin{itemize}
    \item It doesn't recognize IP, Ethernet, TCP, or any protocol at all.
    \item The \textbf{programmer defines everything}: what headers to parse, what fields to match, what actions to perform.
\end{itemize}
This is what makes it \textbf{protocol-independent}, and feature-proof.

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{tools} \textbf{What does the compile do?}}
\end{flushleft}
Here's the key part of PISA and P4: we don't directly \textbf{program the pipeline}, \textbf{the compiler does}. We write a logical program in P4, and the P4 compiler:
\begin{itemize}
    \item Analyzes dependencies between operations:
    \begin{itemize}
        \item \textbf{Match dependency}: A table needs data generated by a previous match.
        \item \textbf{Action dependency}: An action needs a value produced by a previous action.
    \end{itemize}
    \item Packs logic into stages without violating resource limits
    \item Ensure parallelism and no data hazards
\end{itemize}