\paragraph{Program Structure}

In the first Poisson 1D laboratory, we will create three source files:
\begin{itemize}
    \item \texttt{lab-01.cpp}
    \item \texttt{Poisson1D.cpp}
    \item \texttt{Poisson1D.hpp}
\end{itemize}
This split follows a classic \texttt{C++} organization:
\begin{itemize}
    \item Header (\texttt{.hpp}): contains the \textbf{class declaration}. It's the ``blueprint'': all member variables and method signatures are written here. No implementation details.
    \item Implementation (\texttt{.cpp}): contains the \textbf{class implementation}: actual code for each method declared in the header. Here is where we'll find the implementation.
    \item Driver (\texttt{lab-01.cpp}): contains the \texttt{main()} function. This is the entry point: it creates an instance of \texttt{Poisson1D}, calls \texttt{run()}, and handles exceptions.
\end{itemize}
This program structure mirrors the workflow of the Finite Element Method (FEM):
\begin{itemize}
    \item Declare the \textbf{problem} (class declaration $=$ PDE $+$ parameters).
    \item Implement the \textbf{steps} (methods $=$ weak form $\rightarrow$ discrete system).
    \item Run the \textbf{pipeline} (main $=$ assemble $+$ solve).
\end{itemize}
So the program is not ``just code files''. It's intentionally structured to \textbf{mirror the mathematical procedure} we derived in the written part of the lab.