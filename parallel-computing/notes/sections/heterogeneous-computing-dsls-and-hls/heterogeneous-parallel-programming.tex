\subsection{Heterogeneous parallel programming}

\begin{flushleft}
    \textcolor{Red2}{\faIcon{exclamation-triangle} \textbf{Challenges of Writing Portable and Efficient Parallel Code}}
\end{flushleft}
Writing parallel programs for heterogeneous systems is difficult due to the following reasons:
\begin{enumerate}
    \item \important{Diverse Hardware Architectures}. A CPU, GPU, and FPGA all have different programming models. \textbf{Code written for one hardware type may not perform well on another}.
    
    \item \important{Performance vs. Productivity Trade-offs}.
    \begin{itemize}
        \item \textbf{Performance}: Low-level programming (e.g., \hl{CUDA, OpenCL, Verilog}) allows fine-tuned optimizations but \textbf{is hard to program}.
        \item \textbf{Productivity}: High-level abstractions (e.g., \hl{OpenMP, DSLs}) improve productivity but \textbf{may introduce performance overhead}.
    \end{itemize}

    \item \important{Memory Management}. Different memory models (shared vs. distributed) require different optimizations. Data movement between CPU and GPU memory can be costly if not handled efficiently.

    \item \important{Scalability Issues}. Some \textbf{programs scale well on GPUs but poorly on CPUs} due to synchronization and memory bandwidth limitations.
\end{enumerate}

\begin{flushleft}
    \textcolor{Green3}{\faIcon{check-circle} \textbf{The Ideal Parallel Programming Language}}
\end{flushleft}
An \textbf{ideal parallel programming model should provide a balance of}:
\begin{itemize}[label=\textcolor{Green3}{\faIcon{check}}]
    \item \textcolor{Green3}{\textbf{Performance}}. Optimized execution across different hardware.
    \item \textcolor{Green3}{\textbf{Productivity}}. Easy to use and develop.
    \item \textcolor{Green3}{\textbf{Generality}}. Works across different architectures.
\end{itemize}
However, \textbf{most existing languages optimize only one or two} of these factors, leading to trade-offs.

\begin{table}[!htp]
    \centering
    \begin{tabular}{@{} p{12em} | c c c @{}}
        \toprule
        \textbf{Approach} & \textbf{Performance} & \textbf{Productivity} & \textbf{Generality} \\
        \midrule
        \textbf{CUDA/OpenCL}            & \textcolor{Green3}{\faIcon{check} \textbf{High}}      & \textcolor{Red2}{\faIcon{times} \textbf{Low}}         & \textcolor{Red2}{\faIcon{times} \textbf{Low}} \\ [.5em]
        \textbf{OpenMP (CPU)}           & \textcolor{Green3}{\faIcon{check} \textbf{High}}      & \textcolor{Green3}{\faIcon{check} \textbf{Medium}}    & \textcolor{Red2}{\faIcon{times} \textbf{Low}} \\ [.5em]
        \textbf{MPI (Distributed)}      & \textcolor{Green3}{\faIcon{check} \textbf{High}}      & \textcolor{Red2}{\faIcon{times} \textbf{Low}}         & \textcolor{Green3}{\faIcon{check} \textbf{High}} \\ [.5em]
        \textbf{FPGA/Verilog/VHDL}      & \textcolor{Green3}{\faIcon{check} \textbf{Very High}} & \textcolor{Red2}{\faIcon{times} \textbf{Very Low}}    & \textcolor{Red2}{\faIcon{times} \textbf{Low}} \\ [.5em]
        \textbf{High-Level Synthesis}   & \textcolor{Green3}{\faIcon{check} \textbf{High}}      & \textcolor{Green3}{\faIcon{check} \textbf{Medium}}    & \textcolor{Red2}{\faIcon{times} \textbf{Low}} \\
        \bottomrule
    \end{tabular}
\end{table}

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{question-circle} \textbf{Why is this important?}}
\end{flushleft}
If we want \textbf{portable parallel programs}, we need \textbf{new high-level abstractions} like Domain-Specific Languages (DSLs), which will be covered in the next section.