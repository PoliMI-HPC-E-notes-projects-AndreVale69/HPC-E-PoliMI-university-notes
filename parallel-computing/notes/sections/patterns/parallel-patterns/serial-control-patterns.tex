\subsubsection{Serial Control Patterns}

\definition{Serial Control Patterns} are \textbf{fundamental programming constructs that dictate the sequence of execution in a program}. They are the basic building blocks of any algorithm, defining how the flow of control moves through the program from start to finish. In other words, \hl{they determine the order in which tasks are performed}.

\highspace
\begin{flushleft}
  \textcolor{Green3}{\faIcon{question-circle} \textbf{Why \dquotes{serial} control patterns?}}
\end{flushleft}
These patterns are called \dquotes{serial} because the \textbf{tasks} they control are \textbf{executed one after the other}, in a specific order, without overlapping.

\highspace
\begin{flushleft}
  \textcolor{Green3}{\faIcon{stream} \textbf{Types}}
\end{flushleft}
\begin{enumerate}
    \item \definition{Sequence Pattern}
    \begin{itemize}
        \item[\textcolor{Red2}{\faIcon{book}}] \textcolor{Red2}{\textbf{Definition}}. An ordered list of tasks that are executed in a specific order.

        \item[\textcolor{Green3}{\faIcon{question}}] \textcolor{Green3}{\textbf{Assumption}}. The program text ordering will be followed.
        \begin{examplebox}[: Sequence Pattern]
            In the following example, each task must be completed before the next one begins.
            \begin{lstlisting}[language=c]
int A = 10;
int T = foo(A);
int S = bar(T);
int B = delta(S);\end{lstlisting}
        \end{examplebox}
    \end{itemize}
  
    \item \definition{Selection Pattern}
    \begin{itemize}
        \item[\textcolor{Red2}{\faIcon{book}}] \textcolor{Red2}{\textbf{Definition}}. A condition is evaluated first; depending on the result, one of two tasks is executed.

        \item[\textcolor{Green3}{\faIcon{question}}] \textcolor{Green3}{\textbf{Assumption}}. Only one of the tasks will be executed, not both.
        \begin{examplebox}[: Selection Pattern]
            In the following example, the function \texttt{a} is executed if condition \texttt{c} is true; otherwise, function \texttt{b} is executed.
            \begin{lstlisting}[language=c]
if (c) {
    a();
} else {
    b();
}\end{lstlisting}
        \end{examplebox}
    \end{itemize}
  
    \newpage

    \item \definition{Iteration Pattern}
    \begin{itemize}
        \item[\textcolor{Red2}{\faIcon{book}}] \textcolor{Red2}{\textbf{Definition}}. A condition is evaluated, and if true, a task is executed repeatedly until the condition becomes false.

        \item[\textcolor{Red2}{\faIcon{exclamation-triangle}}] \textcolor{Red2}{\textbf{Complication in Parallelizing}}. Dependencies may exist between iterations.
        \begin{examplebox}[: Iteration Pattern]
            In the following example, function \texttt{a} is executed \texttt{n} times. The condition \texttt{i < n} is evaluated, and if true, the function \texttt{a} is repeated until \texttt{i < n} becomes false (then \texttt{i = n}).
            \begin{lstlisting}[language=c]
for (int i = 0; i < n; ++i) {
    a();
}\end{lstlisting}
        \end{examplebox}
    \end{itemize}
  
    \item \definition{Recursion Pattern}
    \begin{itemize}
        \item[\textcolor{Red2}{\faIcon{book}}] \textcolor{Red2}{\textbf{Definition}}. A dynamic form of nesting where functions call themselves.

        \item[\textcolor{Green3}{\faIcon{star}}] \textcolor{Green3}{\textbf{Special Case}}. Tail recursion can be converted into iteration, which is important for functional languages.
        \begin{examplebox}[: Recursion Pattern]
            \begin{lstlisting}[language=c]
int recursive_function(int n) {
    if n > 0
        return n * recursive_function(n - 1);
    return 1; // base case
}\end{lstlisting}
        \end{examplebox}
    \end{itemize}
\end{enumerate}
These patterns are the \textbf{foundation of structured serial programming}. Also, when parallelizing serial algorithm, it's crucial to understand these patterns to effectively manage dependencies and concurrency.